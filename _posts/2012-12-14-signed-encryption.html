---
layout: post
title: Signed Encryption
date: '2012-12-14T09:47:00.000-08:00'
author: Luke Briner
tags:
- signed encryption
- encryption
- aes
- tamper-proof
- AuthenticatedAesCng
modified_time: '2012-12-14T09:47:19.137-08:00'
---

I think I am one of those people who are happy often with being 95% there. If the system is pretty solid or pretty unlikely to fail then I am happy.<br />Take something like encryption. Sadly massively underused despite being easy enough to setup in web applications but it would be easy for me to think, "I have encryption on this data, therefore it is safe". Now ignoring the fact that you need to manage decryption keys and use a decent algorithm etc, what is your gut feel? Is encrypted data safe or not? Our language is casual and we can say that no-one can tamper with it but that is not strictly true. In a decent system, no-one other than the authorised people are allowed to decrypt/read the data but that is not the same as saying it can't be tampered with.<br />An example I heard of before was, imagine that you have a table with employees salaries in it, you notice that the salary column contains encrypted data and you can see your bosses salary, e.g. ABCD and your own salary EFGH. Now although you don't know what the figure for your boss actually is (and you may or may not know what your figure is) what you DO know is that your boss gets paid more than you do so if you were able to update the database so that your salary was also ABCD then you could reasonably imagine that your next pay packet would be larger than the last one! This is nothing to do with encryption but relates to the fact that if the data is encrypted in a deterministic way (which bare algorithms do) then I know I can carry out this attack. In this instance, what I need to do is include some check data in the encrypted column so that I can ensure this copy-in-place attack will fail. This could be anything from some hash derived from the user id to something more complex but breaks the attack.<br />There is, however, another way in which encrypted data can be 'broken' which may or may not be thwarted by the above solution. Although I don't know what the encrypted data means, if I change the encrypted data usually, it will still decrypt but into something else. This may or may not cause a problem but it can potentially break a system. Imagine I managed to tamper with my encrypted salary, sure I might change it from 25,000 to (DHk)(897 but I might also be able to change it to 100,000 by trial and error! The way round it? Some kind of signature. Again, you could perform your own home brew way of checking the integrity of the data but you can also use an industry standard technique to create a digital signature. The reason for this is that a home brew technique might only work some of the time and you really need it to be bomb-proof.<br />I ended up stumbling across a library that worked under .Net alongside the MS implementations of cryptography but which provided this mechanism. It can either use Galois/Counter Mode or Counter with CBC/MAC. This article is <a href="http://blogs.msdn.com/b/shawnfa/archive/2009/03/17/authenticated-symmetric-encryption-in-net.aspx" target="_blank">here</a>. Fortunately, it was a reasonably straight-forward download and install and fortunately, the implementation was fairly straight-forward except for a few important points:<br /><ol><li>Since a tag is generated by the encryption process, you must store this and set it in the decryption process otherwise you are scuppered. You cannot for instance wire in the encryption now and worry about the tag later.</li><li>You need to use the correct types in SQL server to store the tag so that it can be restored later in the correct format. Since it is a byte array, it is easy to get confused with string representations. For this reason, I used binary(16) in SQL Server for the tag and cast the dataReader result to byte[] to retain the correct format and structure.</li></ol>PLEASE NOTE: The following is code modified from OWASP ESAPI to make it work with the AuthenitcatedAesCng but I am not providing any guarantees that this is the best or only way to implement encryption. <br/>The following is the encryption method. In my case, tag is an output parameter since the method itself returns the ciphertext. This tag is saved into the database in another column to the cipher text and obviously retrieved during decryption.<br /> <pre style="font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; color: #000000; background-color: #eee;font-size: 12px;border: 1px dashed #999999;line-height: 14px;padding: 5px; overflow: auto; width: 100%"><code>using (var symmetricAlgorithm = new AuthenticatedAesCng())<br />{<br />    symmetricAlgorithm.CngMode = CngChainingMode.Gcm;<br />    symmetricAlgorithm.GenerateIV();<br />    byte[] iv = symmetricAlgorithm.IV;<br />    symmetricAlgorithm.AuthenticatedData = Encoding.GetEncoding(encoding).GetBytes(&quot;nprvaewuybnppnawn&quot;);<br /><br />    using (MemoryStream msEncrypt = new MemoryStream())<br />    {<br />        using (IAuthenticatedCryptoTransform encryptor = symmetricAlgorithm.CreateAuthenticatedEncryptor(secretKey, iv))<br />        {<br />            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))<br />            {<br />                try<br />                {<br />                    Encoding textConverter = Encoding.GetEncoding(encoding);<br />                    byte[] plaintextBytes = textConverter.GetBytes(plaintext);<br />                    csEncrypt.Write(plaintextBytes, 0, plaintextBytes.Length);<br />                    csEncrypt.FlushFinalBlock();<br /><br />                    byte[] encryptedBytes = msEncrypt.ToArray();<br />                    byte[] encryptedBytesPlusIv = Combine(iv, encryptedBytes);<br />                    tag = encryptor.GetTag();<br />                    return Convert.ToBase64String(encryptedBytesPlusIv);<br />                }<br />                finally<br />                {<br />                    symmetricAlgorithm.Clear();<br />                }<br />            }<br />        }<br />    }<br />}<br /></code></pre><br />And the decryption: <pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>using (var symmetricAlgorithm = new AuthenticatedAesCng())<br />{<br />    symmetricAlgorithm.CngMode = CngChainingMode.Gcm;<br />    byte[] ciphertextBytes = Convert.FromBase64String(ciphertext);<br /><br />    int ivLength = symmetricAlgorithm.IV.Length;<br />    byte[] ivBytes = new byte[ivLength];<br />    Array.Copy(ciphertextBytes, ivBytes, ivLength);<br /><br />    int onlyCiphertextLength = ciphertextBytes.Length - ivLength;<br />    byte[] onlyCiphertextBytes = new byte[onlyCiphertextLength];<br />    Array.Copy(ciphertextBytes, ivLength, onlyCiphertextBytes, 0, onlyCiphertextLength);<br /><br />    symmetricAlgorithm.AuthenticatedData = Encoding.GetEncoding(encoding).GetBytes("nprvaewuybnppnawn");<br />    symmetricAlgorithm.Tag = tag;<br /><br />    using (MemoryStream msDecrypt = new MemoryStream(onlyCiphertextBytes))<br />    {<br />        using (ICryptoTransform decryptor = symmetricAlgorithm.CreateDecryptor(secretKey, ivBytes))<br />        {<br />            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))<br />            {<br />                try<br />                {<br />                    byte[] plaintextBytes = new byte[onlyCiphertextLength];<br />                    int decryptedBytes = csDecrypt.Read(plaintextBytes, 0, onlyCiphertextLength);<br />                    Encoding textConverter = Encoding.GetEncoding(encoding);<br />                    return textConverter.GetString(plaintextBytes, 0, decryptedBytes);<br />                }<br />                finally<br />                {<br />                    symmetricAlgorithm.Clear();<br />                }<br />            }<br />        }<br />    }<br />}<br /></code></pre>The thing to realise is that if someone wanted to tamper with the encrypted data, they would have to tamper with the signature to make it match. The chances of being able to do this are so low as to not present a major risk. Notice the random text I use as a data salt which adds secrecy to the process and makes it harder for someone to try and duplicate.