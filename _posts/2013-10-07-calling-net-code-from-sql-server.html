---
layout: post
title: Calling .Net code from SQL Server
date: '2013-10-07T09:05:00.001-07:00'
author: Luke Briner
tags:
- '2012'
- permissions
- User Defined Function
- sql server
- '2008'
- SQL Server 2008
- visual studio
- sql server 2005
- CLR
- ".net"
- '2005'
- Database Project
modified_time: '2013-10-07T09:05:55.063-07:00'
---

<h2>Introduction</h2>How do you call .Net code from SQL Server and why would you want to? There are various reasons why you might want to but they all come down to a simple answer, "doing something that is easy to do in .Net but driven from a database".<br /><br />In my case, I want to trigger from one database and if certain changes are made, to log these and then call onto a web service to update a dependent system (that does not run on the same SQL server). Obviously the trigger is easy in SQL but logging and calling web services is much easier in .Net - it is also easier to debug from Visual Studio.<br /><br />This is how to do it....<br /><br /><h3>Create a Visual Studio Project</h3>Firstly, create yourself a database project in Visual Studio. I believe some of these have changed names but in Visual Studio 2012, there is only one database project called, "SQL Server Database Project". I think the older versions had several projects with example files in them, in which case, choose the "CLR User Defined Function" project.<br /><br />Once this is created, you might or might not have any code but if not, choose "Add New Item" on the project and look under SQL CLR C# for the item called "SQL CLR C# User Defined Function". Give it a name and add it.<br /><br />Once you see this file, it looks very similar to normal C# but with a special attribute (Microsoft.SqlServer.Server.SqlFunction) that will let it be called from SQL Server. You will also notice that the types live in the System.Data.SqlTypes namespace which ensures they are correctly marshalled between .Net and SQL Server. Otherwise, it is all pretty normal stuff.<br /><h3>Set the Project Properties</h3>Right-click the project in the solution explorer and choose "properties". Here, you can set the names for your assembly (if different from the project name) and also change the target framework to 3.5 if it needs to work on SQL Server 2005/8.<br /><br />You can, and should, also set the Assembly properties so you can more easily keep track of your code. Pressing this button creates an AssemblyInfo file.<br /><br />If your assembly does anything outside of itself like file IO or network access, it will need permission to do so. You specify this by setting the Permission Level (details are <a href="http://technet.microsoft.com/en-us/library/ms345101.aspx" target="_blank">here</a>). If you have chosen anything other than "SAFE", you will need to sign your library. Do this by pressing the Signing button and choosing to sign the assembly, if you do not have a strong key already, you can create one here in the dialog.<br /><h3>Add Login and User</h3>A CLR function needs to be owned by a user (this code will become a database) so you will need to add a user <u>without</u> login to your project and then set this name also in the Project properties against the "Assembly owner" on the first page. If you try and create a login in the project, it will fail deployment later.<br /><h3>Build Project</h3>Build and deploy the project, you should get no errors. You might optionally add additional functions or other tables etc. This build should produce a .dacpac file as well as the assembly dll.<br /><h3>Prepare the SQL Server</h3>The SQL Server will not allow the CLR object to install or run by default.<br /><br />Firstly, you will need to enable CLR integration for the SQL server. Run the following query against the master database:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>sp_configure 'clr enabled', 1<br />GO<br />reconfigure<br />GO<br /></code></pre><br />Note this does not require a restart.<br /><br />Secondly, you need to create a login linked to the key that you used to sign your assembly with. The easiest way is to create an asymmetric key from the assembly file like this:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>CREATE ASYMMETRIC KEY MyKeyName<br />    FROM EXECUTABLE FILE = 'C:\Users\Luke\Documents\Visual Studio 2012\Projects\MyProject\bin\Release\MyAssembly.dll'  <br /></code></pre><br />No password is required in this statement.<br /><br />If you get an error here, it might be because the directory your assembly lives in does not give the SQL server user permission to read the contents of the directory, in&nbsp; which case, just give "Users" permission to read e.g. ...\Myproject\Bin\Release.<br /><br />Next, create a server login (I used the user interface) and point it to the key you just created in the "mapped to asymmetric key" dropdown list. Once you create this login, you need to give the login external access permission like this:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>USE master<br />GO<br />GRANT EXTERNAL ACCESS ASSEMBLY TO [MyLogin]<br /></code></pre><br /><h3>Import the Data-Tier Project</h3>Right-click the databases tab on your server explorer and choose "Deploy data-tier application". The options are quite easy to understand, point it at your dacpac file and press go. What happens during this import is that the server will determine if it is happy to give your CLR code the permissions that were specified in the properties. For instance, if the code requires external access, it will use the assembly signing key to associate the code with a login (the one you just created) which is linked to the same key. This is how the server establishes the trust relationship since only a system admin can create server logins.<br /><h3>Try it out</h3>It works as any other database function does. For instance SELECT DataTierApp.dbo.MyFunc( Param1, Param2)<br />