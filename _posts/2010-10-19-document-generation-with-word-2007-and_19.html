---
layout: post
title: Document Generation with Word 2007 and ASP.NET - part 2
date: '2010-10-19T08:48:00.000-07:00'
author: Luke Briner
tags:
- asp.net
- word 2007
modified_time: '2010-10-19T09:06:30.957-07:00'
---

In the first part, we looked at how to build a document ready to accept dynamic data which can be used to generate dynamic reports. Whether we are planning to use a blank template, individual read/write documents or merging documents together, the basic idea is the same:<br /><ol><br /><li>Get data from data source</li><br /><li>Create XML part for this data</li><br /><li>Insert this data into the document</li><br /><li>Return the result to the client</li><br /></ol><br />Getting data from the data source is beyond the scope of this document but in my case, I have an existing database access layer which I call to return a single row of data (a DataRow).<br />Creating the XML part is quite easy using the XmlWriter class as in the following function:<br /><pre><br />private void GetData(Stream stream, string quoteRef)<br />{<br /> // DataRow dr = etc..<br /> XmlWriter writer = XmlWriter.Create(stream);<br /> writer.WriteStartElement("Quote");<br /> writer.WriteAttributeString("Reference", quoteRef);<br /> writer.WriteElementString("QuoteName", "Test New Quote");<br /> writer.WriteElementString("TotalSellingPrice", Convert.ToDecimal(dr["TotalSellingPrice"]).ToString("N2"));<br /> writer.WriteElementString("TotalCost", Convert.ToDecimal(dr["TotalCost"]).ToString("N2"));<br /> writer.WriteEndElement();<br /> writer.Close();<br />}<br /></pre><br />Since the XML is text, it is convenient to format numbers at this point rather than playing with it in the document (but you can if you need to).<br />To insert this into the document, we need to use the System.IO.Packaging classes which allow you to work on the zip file (which is the docx). You might need to reference WindowsBase.dll if you haven't already to get these classes.<br />My function is then:<br /><pre><br />private void InsertCustomXml(MemoryStream memoryStream)<br />{<br /> // Open the document in the stream and replace the custom XML part<br /> Package pkgFile = Package.Open(memoryStream, FileMode.Open, FileAccess.ReadWrite);<br /> PackageRelationshipCollection pkgrcOfficeDocument = pkgFile.GetRelationshipsByType(strRelRoot);<br /> foreach (PackageRelationship pkgr in pkgrcOfficeDocument)<br /> {<br />  if (pkgr.SourceUri.OriginalString == "/")<br />  {<br />   // Add a custom XML part to the package<br />   Uri uriData = new Uri("/customXML/item1.xml", UriKind.Relative);<br />   if (pkgFile.PartExists(uriData))<br />   {<br />    // Delete template "/customXML/item1.xml" part<br />    pkgFile.DeletePart(uriData);<br />   }<br />   // Load the custom XML data<br />   PackagePart pkgprtData = pkgFile.CreatePart(uriData, "application/xml");<br />   GetData(pkgprtData.GetStream(), "QUO-016952");<br />  }<br /> }<br /> // Close the file<br /> pkgFile.Close();<br />}<br /></pre><br />This function takes a stream which represents a docx document and adds the custom XML in, there is nothing in this function which you would change (except the string parameter passed to GetData) you need a const defined which matches the correct namespace:<br /><pre><br />private const string strRelRoot = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument";<br /></pre><br />The reason I use streams is because I use the system in different ways. To retrieve a single document:<br /><pre><br />public MemoryStream RetrieveDocument(string fileName, bool addCustomXml)<br />{<br /> // Read the file into memory - default constructor is expandable<br /> MemoryStream memoryStream = new MemoryStream();<br /> byte[] buffer = File.ReadAllBytes(fileName);<br /> memoryStream.Write(buffer,0,buffer.Length);<br /> // If we want to add in the XML, do it here otherwise we might want to add it at top level<br /> if (addCustomXml)<br /> {<br />  InsertCustomXml(memoryStream);<br /> }<br /><br /> return memoryStream;   <br />}<br /></pre><br />NOTE the comment that you need to use the default constructor for the memory stream otherwise it will not be expandable when you insert your custom XML.<br />If I am merging several documents (in my case using the Aspose Words dlls from Aspose) I merge the docs and THEN add the custom XML to the main document:<br /><pre><br />public Document MergeDocuments(List<MemoryStream> docs, string templateDoc, string outputPath)<br />{<br /> Document dstDoc = new Document(templateDoc);<br /><br /> foreach (MemoryStream Doc in docs)<br /> {<br />  Document srcDoc = new Document(Doc);<br />  dstDoc.AppendDocument(srcDoc, ImportFormatMode.UseDestinationStyles);<br />  Doc.Close();<br /> }<br /> // Add in the custom XML via the memory stream<br /> MemoryStream ms = new MemoryStream();<br /> dstDoc.Save(ms,SaveFormat.Docx);<br /> InsertCustomXml(ms);<br /> dstDoc = new Document(ms);<br /> return dstDoc;<br />}<br /></pre><br />Aspose merges actual docs whereas I need a memory stream for my functions so I use the Aspose doc class to append documents and then convert it to memory stream to add the custom XML, once it is done, I return a new Aspose doc so it can be saved appropriately. One of the things that is easier in docx is that to merge docs, you can simply merge the content and keep a single set of styles, custom xml and the rest of it but it does mean that any custom XML/styles in individual docs is lost when the documents are merged.<br />In my web layer then, I call these functions and return the result to the browser using content-disposition to hint that it can be saved instead of viewed inline:<br /><pre><br />protected void Page_Load(object sender, EventArgs e)<br />{<br /> TenderGenerator gen = new TenderGenerator();<br /> const string TemplateFile = @"~/App_Data/QuoteTemplate.docx";<br /> List<MemoryStream> myList = new List<MemoryStream>();<br /> myList.Add(gen.RetrieveDocument(@"c:\work\QuoteDocuments\QUO-016952\Documents\UniqueReport.docx", false));<br /> myList.Add(gen.RetrieveDocument(@"c:\work\QuoteDocuments\QUO-016952\Documents\Financial Summary.docx", false));<br /> Document doc = gen.MergeDocuments(myList, Server.MapPath(TemplateFile), "");<br /> doc.Save(Response, "CustomerDocument.docx", ContentDisposition.Attachment, SaveOptions.CreateSaveOptions(SaveFormat.Docx));<br /> Response.End();<br />}<br /></pre><br />In this case, I have a test page so the doc paths are hard-coded and the whole thing is driven from the page load event, in real life, this will be driven from a button press and database driven list of docs. Note that I use the template file stored in App_Data which already has the custom XML linked to it so that the top level document can have the custom XML replaced (in the previous post I mentioned that for some reason, if the custom XML is not present, the new data is not added in its place). Hopefully this is all easy enough to understand.