---
layout: post
title: Making AES256 encryption work the same in PHP as .Net
date: '2013-04-11T09:23:00.000-07:00'
author: Luke Briner
tags:
- ".net"
- Rfc2898DeriveBytes
- aes
- padding
- mcrypt
- mcrypt_decrypt
- aes256
- rijndael
- rijndael_128
- php
- pkcs7
modified_time: '2013-04-11T09:23:55.123-07:00'
---

Further to my previous post, I had data which I had encrypted using AES256 and which I needed to decrypt in PHP. This made me shudder when I realised that I had used a third-party library in .Net and which could do a load of things that might not be possible in PHP. Fortunately, these things really are standard and I'm please to report that it was possible to do this in PHP.<br /><br />The examples here are only for decryption since I do all the encryption in .Net but the basic principle is the same. This is the function I eventually used:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>protected function Decrypt($ciphertext)<br />{<br />    try<br />    {<br />        $key = $this-&gt;pbkdf2(Microsoft_WindowsAzure_RoleEnvironment::getConfigurationSettingValue("Password"),<br />                Microsoft_WindowsAzure_RoleEnvironment::getConfigurationSettingValue("Salt"),1000,32);<br />        $cipherTextBytes = base64_decode($ciphertext);<br />        $ivBytes = substr($cipherTextBytes,0,16);<br />        $cipherTextBytesOnly = substr($cipherTextBytes,16);<br />        $decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $cipherTextBytesOnly, MCRYPT_MODE_CBC, $ivBytes);<br />        # mcrypt pads the decrypted data with a character whose value is equal to the number of padding characters added<br />        $dec_s = strlen($decrypted); <br />        $padding = ord($decrypted[$dec_s-1]); <br />        if ( $padding &lt;= 16 )<br />        {<br />            # string might not be padded<br />            return substr($decrypted, 0, -$padding); <br />        }<br />        else<br />        {<br />            return $decrypted;<br />        }<br />        <br />    }<br />    catch (Exception $e)<br />    {<br />        return null;<br />    }<br />}<br /></code></pre><br />Firstly, a correct key must be derived, in my case from a password and the master salt which are configuration variables in Azure (this password/salt system is based on the owasp implementation of ESAPI). The method being called is shown below and matches the functionality of the .Net Rfc2898DeriveBytes class.<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>private function pbkdf2( $p, $s, $c, $kl, $a = 'sha1' ) {<br />    $hl = strlen(hash($a, null, true)); # Hash length<br />    $kb = ceil($kl / $hl);              # Key blocks to compute<br />    $dk = '';                           # Derived key<br /><br />    # Create key<br />    for ( $block = 1; $block &lt;= $kb; $block ++ ) {<br />        # Initial hash for this block<br />        $ib = $b = hash_hmac($a, $s . pack('N', $block), $p, true);<br />        # Perform block iterations<br />        for ( $i = 1; $i &lt; $c; $i ++ )<br />            $ib ^= ($b = hash_hmac($a, $b, $p, true));  # XOR each iteration<br /><br />        $dk .= $ib; # Append iterated block<br />    }<br />    return substr($dk, 0, $kl);<br />}<br /></code></pre><br />I did not write the pbkdf2 function but found it on a github <a href="https://github.com/dchymko/.NET--PHP-encryption" target="_blank">demo project</a> (thanks!)<br /><br />The original encrypted data is base64 encoded to allow it to be sent over non-binary safe channels so firstly this is reversed. Then, the standard way to store the initialisation vector is as the first x bytes of the stored data - 16 in the case of AES256. This is taken from the front of the data and the remainder becomes the actual encrypted data.<br /><br />The function then uses mcrypt_decrypt using the RIJNDAEL_128 algorithm. This is because the 128 here is the block size of the cipher, whereas the 256 in the AES is the key length (in bits).<br /><br />Another by-product of using mcrypt_decrypt is the use of padding in PKCS7 format. This means that the decrypted data will be padded to the next 16 byte block using a character whose ascii code is the same as the number of padding characters that have been added so "help" would be decrypted as "help\f\f\f\f\f\f\f\f\f\f\f\f" since \f is 12 in ascii form. The remainder of the function then checks that the last digit is a padding character (&lt;= 16) and if it is, removes these from the decrypted string. There is the possibility if you are decrypting binary data that the last character of data is actually less than 0x10 which would make the padding code think there are padding characters to remove but this won't happen with strings (which is what I am using).