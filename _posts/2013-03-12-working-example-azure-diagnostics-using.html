---
layout: post
title: Working Example - Azure Diagnostics using log4net and table storage
date: '2013-03-12T06:44:00.001-07:00'
author: Luke Briner
tags:
- not working
- Azure
- storage
- errors
- log4net
- trouble-shooting
- diagnostics
- tracing
modified_time: '2013-03-12T06:44:39.845-07:00'
---

<h3>Introduction </h3>This has had me tearing my hair out - and I don't have much anyway but I have had so many problems with diagnostic logging in Azure that it has quite literally tempted me to ditch Platform as a Service and go back to Infrastructure as a Service and have to hand-craft all my boxes.<br />The problem is a cloud problem. How do you use traditional file-based logs on boxes that might be recycled, added to or removed from at any time? How do you merge logs from multiple instances into a single file? The obvious answer is that you can't really. Microsoft have provided a mechanism however using the DiagnosticMonitorTraceListener which is designed to copy log data from the standard System.Diagnostics trace data into permanent Azure storage and this will work across multiple instances into a single table.<br />Before we start, I would seriously advise starting with the simplest example possible and building it up once you know it works. I fall foul of this so often when I start with a large example with too many variables.<br />You will need all of these sections so in no particular order...<br /><h3>WebRole.cs</h3>This is the entry point for your role and might be called something different but you will need to modify OnStart to setup your transfer schedule:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>public override bool OnStart()<br />{<br />    Trace.Listeners.Add(new DiagnosticMonitorTraceListener());<br />    string wadConnectionString = "Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString";<br />    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(RoleEnvironment.GetConfigurationSettingValue(wadConnectionString));<br />    RoleInstanceDiagnosticManager roleInstanceDiagnosticManager = storageAccount.CreateRoleInstanceDiagnosticManager(RoleEnvironment.DeploymentId, RoleEnvironment.CurrentRoleInstance.Role.Name, RoleEnvironment.CurrentRoleInstance.Id);<br />    DiagnosticMonitorConfiguration config = DiagnosticMonitor.GetDefaultInitialConfiguration();<br />    config.Logs.ScheduledTransferPeriod = TimeSpan.FromMinutes(1D);<br />    config.Logs.ScheduledTransferLogLevelFilter = LogLevel.Error;<br />    config.WindowsEventLog.DataSources.Add("Application!*[System[Provider[@Name='HostableWebCore']]]");<br />    config.WindowsEventLog.ScheduledTransferPeriod = TimeSpan.FromMinutes(1);<br />    roleInstanceDiagnosticManager.SetCurrentConfiguration(config);<br />    return base.OnStart();<br />}<br /></code></pre><br />The first line might or might not be necessary but it does allow you to trace information from within this webrole. This is important because the webrole runs as a different account from the IIS worker role and will have different permissions.<br />The rest of the code effectively sets up the connection string for storage (Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString) and configures how often and at what level to transfer logs from trace into storage. Most examples uses 1 minute and in my case, I only want the Error traces (and above) transferred, not everything.<br />Notice I am copying Windows event log entries but only where the Provider is HostableWebCore which is what the web application runs as.<br /><h3>web.config</h3>Because of the order I did these changes in, I'm not sure whether the addition of the trace listener into web config is just a duplication of the one added in WebRole.cs or whether this is also required for the web application logging. It doesn't seem to do any harm so here it is:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>&lt;system.diagnostics&gt;<br />    &lt;trace autoflush="true"&gt;<br />      &lt;listeners&gt;<br />        &lt;add type="Microsoft.WindowsAzure.Diagnostics.DiagnosticMonitorTraceListener, Microsoft.WindowsAzure.Diagnostics" name="AzureDiagnostics"&gt;<br />          &lt;filter type="" /&gt;<br />        &lt;/add&gt;<br />      &lt;/listeners&gt;<br />    &lt;/trace&gt;<br />  &lt;/system.diagnostics&gt;<br /></code></pre><br />Nothing magical here, just the standard way to specify a trace listener. Because I copy the diagnostics assembly locally, I do NOT add the public key and culture information which I believe forces web config to look into the GAC for the assembly which may or may not be present.<br /><h3>log4net.config</h3>This might be included in your web config but in my case it is in a separate file to keep web.config cleaner.<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>&lt;configuration&gt;<br />  &lt;configSections&gt;<br />    &lt;section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net"/&gt;<br />  &lt;/configSections&gt;<br />  &lt;log4net&gt;<br />    &lt;appender name="TraceAppender" type="MyAssemblyName.Security.AzureTraceAppender, MyAssemblyName"&gt;<br />      &lt;layout type="log4net.Layout.PatternLayout"&gt;<br />        &lt;conversionPattern value="%date [%thread] %-5level %logger [%property{NDC}] - %message%newline" /&gt;<br />      &lt;/layout&gt;<br />    &lt;/appender&gt;<br />    &lt;root&gt;<br />      &lt;level value="ERROR"/&gt;<br />      &lt;appender-ref ref="TraceAppender"/&gt;<br />    &lt;/root&gt;<br />  &lt;/log4net&gt;<br />&lt;/configuration&gt;<br /></code></pre><br />What you will notice is that I am NOT directly using the log4net TraceAppender but a sub-class called AzureTraceAppender. I got this code, thanks to <a href="http://social.msdn.microsoft.com/Forums/en-US/windowsazuretroubleshooting/thread/05a82e48-e706-43ca-9364-80aa14784618">Pete McEvoy</a> who noticed that the log4net TraceAppender logs everything using Trace.Write which basically outputs everything as INFO level and which therefore is blocked by any filtering done by the DiagnosticMonitorTraceListener. His suggestion is the following code in a sub-class in your project which does what it should have done in the first place:<br /><h3>AzureTraceAppender.cs</h3><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>using System.Diagnostics;<br />using log4net.Appender;<br />using log4net.Core;<br /><br />namespace MyAssemblyName.Security<br />{<br />    public class AzureTraceAppender : TraceAppender<br />    {<br />        protected override void Append(LoggingEvent loggingEvent)<br />        {<br />            var level = loggingEvent.Level;<br />            var message = RenderLoggingEvent(loggingEvent);<br />            if (level &gt;= Level.Error)<br />                Trace.TraceError(message);<br />            else if (level &gt;= Level.Warn)<br />                Trace.TraceWarning(message);<br />            else if (level &gt;= Level.Info)<br />                Trace.TraceInformation(message);<br />            else<br />                Trace.Write(message);<br />            if (ImmediateFlush)<br />                Trace.Flush();<br />        }<br />    }<br />}<br /></code></pre><br /><h3>YourCodeFile.cs</h3>In your code, you can then simply use log4net as you normally would: log.Error("My Error");<br /><h3>Conclusion</h3>If this all works as expected, your application, once deployed to Azure should create a table in the table storage of the storage account used on your application called WADLogsTable. To ensure this works, you could add a simple Trace.WriteError("Starting role"); into your web role OnStart method and this will at least ensure early on that it works. Windows logs are copied into blob storage, I can't remember the exact container name but it is something obvious like wad-iislogs.<br />If it doesn't work. Try using System.Diagnostics.Trace.WriteError() instead of log.Error() and this will bypass log4net and see whether the problem is with your log4net config or the DiagnosticMonitorTraceListener configuration. Also, check what your diagnostic connection string is set to in your cloud role configuration, especially after moving storage accounts!