---
layout: post
title: AES Encryption/Decryption in Android using SpongyCastle
date: '2013-11-13T04:29:00.000-08:00'
author: Luke Briner
tags:
- example
- Java
- encryption
- aes
- Decryption
- aes256
- BouncyCastle
- Android
- SpongyCastle
modified_time: '2014-01-03T08:19:46.563-08:00'
---

At the moment, Android have handicapped the BouncyCastle security library included with Android so that it doesn't support some of the more common and useful encryption algorithms. I will assume this was done for performance reasons but also possibly because older handsets might not support some of the algorithms? Anyway, I don't care and I want AES256 encryption.<br /><br />I found out that the writers of BouncyCastle had another project called SpongyCastle which is the full library for Android and includes all the features I wanted. It is easy to download from <a href="http://rtyley.github.io/spongycastle/" target="_blank">here</a>. Once you have the library installed, it works much the same way as BouncyCastle but with different namespaces. Here is an example of a module that includes encryption and decryption using AES256, a randomly generated key, which is stored in private memory on the device and the ability to use this key to encrypt or decrypt data which can be stored in other files.<br /><br />Any comments most welcome on whether I have got this correct for Android. Note I can't promise that I have used the most efficient or suitable cipher types but this does work! Also note that the initialization vector, which ensures that encrypting the same data multiple times does not produce the same ciphertext, is added to the encrypted data and stored with it, it must therefore, be stripped off before decryption.<br /><br />I am unsure as to the best way to read in data from file with an unknown length. The method I have used below is to make a preset-sized buffer (larger than the data I am storing) and then once it is read in, using the length to create a new buffer and copying the data over. This ensures that the buffer length is correct otherwise the decryption gets confused about padding information. <br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>package org.MyCompany.MyApp;<br /><br />import java.io.FileInputStream;<br />import java.io.FileNotFoundException;<br />import java.io.FileOutputStream;<br />import java.io.IOException;<br />import java.security.NoSuchAlgorithmException;<br />import java.security.SecureRandom;<br /><br />import javax.crypto.KeyGenerator;<br />import javax.crypto.SecretKey;<br />import javax.crypto.spec.SecretKeySpec;<br /><br />import org.spongycastle.crypto.engines.AESFastEngine;<br />import org.spongycastle.crypto.modes.CBCBlockCipher;<br />import org.spongycastle.crypto.paddings.PaddedBufferedBlockCipher;<br />import org.spongycastle.crypto.params.KeyParameter;<br />import org.spongycastle.crypto.params.ParametersWithIV;<br />import org.spongycastle.util.Arrays;<br /><br />import android.content.Context;<br /><br />/**<br /> * Handles the security aspects of the app such as encryption and offline storage<br /> * Reference takens from http://android-developers.blogspot.co.uk/2013/02/using-cryptography-to-store-credentials.html <br /> * @author Luke<br /> *<br /> */<br />public class SecurityModule <br />{<br />    /**<br />     * Store the given serialized data onto the local device<br />     * @param pointsSer<br />     * @return<br />     */<br />    public static Boolean StoreMyData(String myData)<br />    {<br />        SecretKey key = CreateOrRetrieveSecretKey();<br />        if ( key == null )<br />            return false;<br />        <br />        WriteData(encrypt(myData.getBytes(), key.getEncoded()), "mydata.ser");<br />        <br />        return true;<br />    }<br />    <br />    /**<br />     * Get the cryptographically securely stored data for this application<br />     * @return<br />     */<br />    public static String GetMyData()<br />    {<br />        SecretKey key = CreateOrRetrieveSecretKey();<br />        if ( key == null )<br />            return "";<br />        <br />        byte[] data;<br />        try <br />        {<br />            data = ReadData("mydata.ser");<br />        } <br />        catch (IOException e) <br />        {<br />            e.printStackTrace();<br />            return "";<br />        }<br />        <br />        byte[] decrypted = decrypt(data, key.getEncoded());<br />        return new String(decrypted);<br />    }<br />    <br />    /**<br />     * Encrypt the given plaintext bytes using the given key<br />     * @param data The plaintext to encrypt<br />     * @param key The key to use for encryption<br />     * @return The encrypted bytes<br />     */<br />    private static byte[] encrypt(byte[] data, byte[] key) <br />    {<br />        // 16 bytes is the IV size for AES256<br />        try<br />        {<br />            PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));<br />            // Random iv<br />            SecureRandom rng = new SecureRandom();<br />            byte[] ivBytes = new byte[16];<br />            rng.nextBytes(ivBytes);<br />            <br />            cipher.init(true, new ParametersWithIV(new KeyParameter(key), ivBytes));<br />            byte[] outBuf   = new byte[cipher.getOutputSize(data.length)];<br />        <br />            int processed = cipher.processBytes(data, 0, data.length, outBuf, 0);<br />            processed += cipher.doFinal(outBuf, processed);<br />            <br />            byte[] outBuf2 = new byte[processed + 16];        // Make room for iv<br />            System.arraycopy(ivBytes, 0, outBuf2, 0, 16);    // Add iv<br />            System.arraycopy(outBuf, 0, outBuf2, 16, processed);    // Then the encrypted data<br />            <br />            return outBuf2;<br />        }<br />        catch(Exception e)<br />        {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br />    <br />    /**<br />     * Decrypt the given data with the given key<br />     * @param data The data to decrypt<br />     * @param key The key to decrypt with<br />     * @return The decrypted bytes<br />     */<br />    private static byte[] decrypt(byte[] data, byte[] key) <br />    {<br />        // 16 bytes is the IV size for AES256<br />        try<br />        {<br />            PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));<br />            byte[] ivBytes = new byte[16];<br />            System.arraycopy(data, 0, ivBytes, 0, ivBytes.length); // Get iv from data<br />            byte[] dataonly = new byte[data.length - ivBytes.length];<br />            System.arraycopy(data, ivBytes.length, dataonly, 0, data.length    - ivBytes.length);<br />    <br />            cipher.init(false, new ParametersWithIV(new KeyParameter(key), ivBytes));<br />            byte[] decrypted = new byte[cipher.getOutputSize(dataonly.length)];<br />            int len = cipher.processBytes(dataonly, 0, dataonly.length, decrypted,0);<br />            len += cipher.doFinal(decrypted, len);<br />    <br />            return decrypted;<br />        }<br />        catch(Exception e)<br />        {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br />    <br />    /**<br />     * Check for a currently saved key and if not present, create a new one<br />     * @return The newly or previously created key<br />     */<br />    private static SecretKey CreateOrRetrieveSecretKey()<br />    {<br />        try<br />        {<br />            byte[] keyBytes = ReadKey();<br />            SecretKey key;<br />            if ( keyBytes == null )<br />            {<br />                key = GenerateKey();<br />                WriteKey(key.getEncoded());<br />            }<br />            else<br />            {<br />                 key = new SecretKeySpec(keyBytes, 0, keyBytes.length, "AES");<br />            }<br />            return key;<br />        }<br />        catch( NoSuchAlgorithmException e )<br />        {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br />    <br />    /**<br />     * Generate a key suitable for AES256 encryption<br />     * @return The generated key<br />     * @throws NoSuchAlgorithmException<br />     */<br />    private static SecretKey GenerateKey() throws NoSuchAlgorithmException {<br />        // Generate a 256-bit key<br />        final int outputKeyLength = 256;<br /><br />        // EDIT - do not need to create SecureRandom, this is done automatically by init() if one is not provided<br />        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");<br />        keyGenerator.init(outputKeyLength);<br />        SecretKey key = keyGenerator.generateKey();<br />        return key;<br />    }<br />    <br />    /**<br />     * Write the given data to private storage<br />     * @param data The data to store<br />     * @param filename The filename to store the data in<br />     */<br />    private static void WriteData(byte[] data, String filename)<br />    {<br />        FileOutputStream fOut = null;<br />        try {<br />            fOut = MyApp.getAppContext().openFileOutput(filename, Context.MODE_PRIVATE);<br />            fOut.write(data);<br />            fOut.flush();<br />            fOut.close();<br />        } catch (Exception e) {<br />            e.printStackTrace();<br />        }<br />    }<br /><br />    /**<br />     * Write the given encryption key to private storage using the hard-coded filename<br />     * @param key The key to write<br />     */<br />    private static void WriteKey(byte[] key)<br />    {<br />        WriteData(key, "myappkey");<br />    }<br />    <br />    /**<br />     * Read data from private storage using the given filename<br />     * @param filename The filename whose contents to read<br />     * @return The contents of the file or null<br />     * @throws IOException<br />     */<br />    private static byte[] ReadData(String filename) throws IOException<br />    {<br />        byte[] key = new byte[5096];<br />        Arrays.fill(key, (byte)0);<br />        FileInputStream fOut = null;<br />        try <br />        {<br />            fOut = MyApp.getAppContext().openFileInput(filename);<br />            int length = fOut.read(key);<br />            byte[] key2 = new byte[length];<br />            System.arraycopy(key, 0, key2, 0, length);<br />            fOut.close();<br />            return key2;<br />        } <br />        catch(FileNotFoundException e)<br />        {<br />            return null;<br />        } <br />    }<br />    <br />    /**<br />     * Read the encryption key from private storage<br />     * @return<br />     */<br />    private static byte[] ReadKey()<br />    {<br />        try <br />        {<br />            return ReadData("myappkey"); // Hard-coded filename representing the encryption key<br />        } <br />        catch (IOException e) <br />        {<br />            e.printStackTrace();<br />        }<br />        return null;<br />    }<br />}<br /><br /></code></pre><br />