---
layout: post
title: MVC hacking for foreign keys
date: '2011-06-16T05:49:00.000-07:00'
author: Luke Briner
tags:
modified_time: '2011-06-16T05:59:45.043-07:00'
---

I have an unusual scenario for MVC entity framework 4. Firstly I have a table with a primary key (not used for foreign keys) and a unique constraint (which is used for foreign keys). Entity framework does not recognise unique constraints and therefore does not let you use them for foreign keys. The fix is to open the crm.edmx in an xml editor (you might be able to do it from the designer!) and then change the key to point to your unique field and not to your primary key. This allows EF4 to point foreign keys to your field. If you had already created the keys and then re-generated, you might have found that the associations have lost their referential settings which you will need to restore. Obviously if you regenerate, this change might be undone.<br />The second issue is that although one of my table columns has a theoretical foreign key to another table, the key does not exist which allows us to test the scenario where an item is orphaned (the foreign key does not exist on the customer system), therefore EF does not provide all the wiring up for a drop-down list on my view to edit this 'foreign' field. The answer is to use a ViewModel which is simply a class that contains your entity and any other supporting data, in my case a list of SelectItem which is used in the DropDown list. This is populated in the constructor. Then rather than creating the view against the entity, you specify the view model instead and link fields to Model.EntityPropertyName.Name rather than just Model.Name. This also means you can simply link your drop down to the list of SelectItem in the view model which does not exist in the entity itself:<br /><pre><br /> public class AccountDetailViewModel<br />    {<br />        public AccountDetailViewModel()<br />        {<br />            AccountDetail = new AccountDetail();<br />        }<br /><br />        public AccountDetailViewModel(AccountDetail source)<br />        {<br />            AccountDetail = source;<br />            // Get list of 'Account' entities from db and add number and rowid to the list<br />            var accounts = new Entities().Accounts;<br />            Accounts = new List<SelectListItem>();<br />            foreach (var acc in accounts)<br />            {<br />                Accounts.Add(new SelectListItem{ Text= acc.AccountNumber, Value= acc.RowId.ToString()});<br />            }<br />        }<br /><br />        public AccountDetail AccountDetail { get; set;}<br />        public List<SelectListItem> Accounts { get; set; }<br />    }<br /><br /></pre><br />And then in the view:<br /><pre><br /><%: Html.DropDownListFor(model => model.AccountDetail.PrimeAccountInternalRefNo, Model.Accounts, Strings.DropDownListSelectItem)%><br /><%: Html.ValidationMessageFor(model => model.AccountDetail.PrimeAccountInternalRefNo)%><br /></pre>