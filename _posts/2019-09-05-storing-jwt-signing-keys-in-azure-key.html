---
layout: post
title: Storing JWT signing keys in Azure Key Vault and access from .Net
date: '2019-09-05T06:17:00.002-07:00'
author: Luke Briner
tags:
- ".net"
- JWT
- Azure
- Key Vault
- ".Net Core"
modified_time: '2019-09-05T06:17:21.745-07:00'
---

<h2>Summary</h2>You cannot retrieve the private key of a "key" stored in Azure Key Vault (AKV). This makes sense for high-security encryption mechanisms since although not all keys are backed by a Hardware Security Module in AKV, this behaviour reinforces the idea that you can never "get" the private key, you can only delegate its use for encryption or decryption to AKV.<br /><br />There are, however, times when you want to access the private key so that you can use it in code and AKV "keys" are therefore not usable. Instead you need to use "Certificates" and to retrieve the private key, you need to use GetSecretAsync.<br /><br />I will explain why and show code below for .Net. The basic ideas should translate into other languages however.<br /><h2>Why to retrieve the private key</h2>If we delegate the encryption operation to AKV, there are two potential problems. The first is whether AKV even supports what you are doing. I am signing JWTs with a private key and I am not sure this is possible with AKV but I haven't really looked. The second problem is the cost of delegating thousands of operations to AKV when you can do them for free in your own code, which you are already paying to host!<br /><br />The cheapest option is 2.3p per 10K operations for RSA2048 keys. This might not sound like much but it could quickly add up for scalable applications. Imagine 10000 per minute 24/7 and you would be paying over £1000/month for the privilege! This is a very possible number based on microservices and re-authentication taking place. If you want the premium tier for HSM backed keys or any key other than RSA2048, it will cost even more.<br /><br />Well anyway, thanks to <a href="https://azidentity.azurewebsites.net/post/2018/07/03/azure-key-vault-certificates-are-secrets" target="_blank">this</a> blog, I found out how to store a private key in AKV that can be retrieved in code. The answer is Certificates.<br /><h2>How do certificates work in AKV</h2>Certificates are X509 certificates and as you probably know, they consist of a private and public key pair and an optional certificate chain to a root cert, if that is useful. In our case, it is not useful because we control both ends of the signing conversation, we will not need to check that the issuer is sound and there is no direct mechanism to perform this anyway as long as we have a secure way to find the public key to validate our signature.<br /><br />A certificate costs just over £2.00 to issue (for some reason!) but costs the same as normal key operations at 2.3p/10K, although in this case, by downloading and caching the keys in our services, we will not reach anywhere near the numbers required for encryption delegation to AKV.<br /><br />An important technical detail is that if you add a certificate, it automatically adds a key and a secret with the same name. You CANNOT get a private key with GetCertificate or GetKey so you will need to use GetSecret to build your key! GetKey will get you the public key, which might be useful later. <br /><h2>Why use AKV at all?</h2>This probably begs another question: If we have to workaround the pricing and we could generate our own keys locally and we are potentially exposing the private key to the world, why bother using AKV at all? For one very simple reason: to be able to rotate keys centrally at regular intervals with minimum fuss.<br /><br />Have you ever updated an SSL certificate? It is a pain. Even if you have Lets Encrypt (which is designed for web sites rather than signing) there are many steps to do this and many ways to get it wrong. AKV provides the means to simply issue a new certificate and to write our code to automatically use the new certificate and delete the old one after a suitable time.<br /><h2>How to setup key vault</h2>There are other guides about setting up key vault but if anything, they can be too long and complicated. If you have used Azure, you should know how to add a resource in a resource group, give it a name etc. You can choose standard or premium which currently offer the same prices except for HSM-backed keys which are only supported on premium.<br /><h2>Setup Application Access</h2>This is the messiest part since adding applications in Azure AD is confusing. Although you only want an id/secret for your application, you add an application like it is an OAuth2 client with a name that needs to be a URL (use whatever you want) and an optional redirect URI (which you don't need).<br /><br />Anyway, you add this under "App Registrations" in Azure AD and this will display a secret (which you can't see again so write it down or generate a new one later).<br /><br />Note that if you are running on Azure, you definitely want to use <a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview" target="_blank">Managed Service Identities</a> to access the key store instead of normal creds but in my example, I am running on-prem and can't use them. Managed Service Identities allow you to restrict access for an app to a resource without ever seeing or being able to see its login credentials.<br /><br />Once you have the App Registration (or MSI), you need to go to Access Policies in the AKV page and setup permissions. You can change these later so start with more basic permissions. In my example, you just need GET for Secrets.<br /><h2>Writing the Code</h2>Annoyingly, some of the starter guides are hard to find or follow - MS definitely have the "feel of death" on their documentation site and I have personally spotted noticeable mistakes that have been corrected, which doesn't give me good feelings when I am trying to learn a new technology.<br /><br />Anyway, start by installing nuget packages for:<br /><ul><li>Microsoft.Azure.KeyVault</li><li>Microsoft.IdentityModel.Clients.ActiveDirectory</li><li>System.IdentityModel.Tokens.Jwt (if you are signing JWTs like me!)</li></ul>Note that your certificate (and key and secret) will have a base name that you give them when you create them in Azure. They also have a version guid. Both of these are required to decrypt/verify since you need the exact version but if you just want the latest, the key name is all you need.<br /><br />You can create the KeyVaultClient in a number of ways but the example here is what you use with an id/secret as opposed to Managed Service Identity.<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">var kvClient = new KeyVaultClient(async (authority, resource, scope) =&gt;<br />{<br />&nbsp;&nbsp;&nbsp; var adCredential = new ClientCredential("client-id-guid", "secret");<br />&nbsp;&nbsp;&nbsp; var authenticationContext = new AuthenticationContext(authority, null);<br />&nbsp;&nbsp;&nbsp; return (await authenticationContext.AcquireTokenAsync(resource, adCredential)).AccessToken;<br />});</span></span> <br /><br />In this example, we simply create a credential that is passed to the AcquireTokenAsync method of the context. A lot of async and weirdness but easy enough to copy-and-paste!<br /><br />With the client, we can now get the key in the form of the certificate's "secret". Note that there is a difference between getting the latest version, which uses this:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">var secret = await kvClient.GetSecretAsync(keyVaultConfig.KeyVaultUrl, jwtKey);</span></span><br /><br />and getting a specific version:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">var secret = await kvClient.GetSecretAsync(keyVaultConfig.KeyVaultUrl, jwtKey, version);</span></span><br /><br />where these parameters are all strings.<br /><br />Once we have the secret, we can create a certificate directly from it's value:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">var cert = new X509Certificate2(Convert.FromBase64String(secret.Value));</span></span><br /><br />and if we want an RsaSecurityKey from the certificate, we need to do this:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">var key = new RsaSecurityKey(cert.GetRSAPrivateKey());</span></span><br /><br />We need to understand the concept of keyid and how it relates to being able to find the public key needed for verification by now, we have all the elements we need. It is up to you how you cache these responses. The version means that the key for a given version will never change after creation, making them highly cacheable.<br /><h2>Key Id in Json Web Tokens</h2>If we sign a JWT (or strictly a JWS) with a symmetrical key, we don't need to do anything special, although we could set a keyid if we plan to swap or rotate these shared keys. The key id is not defined so you can use whatever you want as its value:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">key.KeyId = "The id of your key";</span></span><br /><br />Setting this before creating your JWT will set the string as the value of <b>kid</b> in the header.<br /><br />If you are using asymmetrical signing (and you should!) then you can use this kid in two different ways. Firstly, in our example, you could simply put the name and version of the key as its key id (but not the vault URL!) for example: keyname/128379831798173973187193 which means when you are verifying, you will need to lookup this key in the vault.<br /><br />Fortunately, this is not only easy to do but because the key id is basically a URL, you can call GetSecret with ("keyname/128379831798173973187193") and it translates to exactly the same as GetSecret(vault, "keyname","128379831798173973187193"). In other words, you can attach an IssuerSigningKeyResolver to your TokenValidationParameters (in dotnet) and simply pass this:<br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;, Courier, monospace;">private IEnumerable<securitykey> IssuerSigningKeyResolver(string token, SecurityToken securitytoken, string kid, TokenValidationParameters validationparameters)<br />{<br />&nbsp;&nbsp;&nbsp; var key = Task.Run(() =&gt; GetKeyFromStore(kid)).Result;<br />&nbsp;&nbsp;&nbsp; return new List<securitykey> { key };<br />}</securitykey></securitykey></span></span><br /><br />which calls the normal method that goes to the store (or hits cache) and then returns an enumerable of key. I think the enumerable allows for a keyid that effectively refers to a set of keys which you might not be able to resolve into a single key so you just pass back the whole set.<br /><h2>Use cases to consider</h2>The happy path is finished but there are other considerations that need to be implemented and tested:<br /><ol><li>I am going to create a static endpoint with the public keys available to verify with as a simple JWK file and am going to set the jku header to point to this list. This will avoid the need to call the key store for public keys and can be cached but care needs to be taken to update this list when certificates are renewed, to make sure you include any live keys as well as the latest one and also not make it cached for so long that updated certs takes too long to propagate.</li><li>I have to test what happens when I renew the certificate. I don't think my current code will work properly so I need to think about how this works.</li><li>I need to test failure scenarios. At minimum, a broken token should not work but I would rather not cause something to crash if an attacker hits it, I would rather it failed gracefully and logged problems. There are various potentially attacks including replay attacks and downgrade attacks like someone setting the algorithm to "none". I can run unit tests to work out how they will failure but then, again, I need some better error handling that perhaps catches all exceptions, logs them and then returns a null user to the caller.</li></ol>