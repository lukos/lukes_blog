---
layout: post
title: Docker build not using the cache
date: '2021-07-08T06:07:00.002-07:00'
author: Luke Briner
tags:
- docker
modified_time: '2021-07-08T06:07:52.269-07:00'
---

<p>&nbsp;One of the main benefits of Docker and a feature that makes it usable in the first place is the use of cacheable layers.</p><p>In short, most statements in a docker file make whatever changes they make at which point the differences from the previous filesystem are tar'd and then the hash of this is used to store a copy of just that layer.</p><p>When we build again, if the files are the same then Docker can determine that it doesn't need to run the statement(s) again but can simply use the cached layer from before.</p><p>This is the main reason why you need to keep rarely changing things as far up the dockerfile and more changed items lower down.</p><p>However, it doesn't always seem to work and sometimes it doesn't seem to use the cache even though you don't think you have changed anything that is relevant.</p><p>Here are some reasons:</p><ol style="text-align: left;"><li>Do not use <b>COPY . .</b> as a way of reducing the number of lines you need to do the copy. In most cases, you will only need a few files to begin with that you might, for example. run npm install against. You might then copy the rest of the source files to build it. If you COPY . . before running npm install, then any time you change ANY source file, you will run npm install all again!</li><li>Make sure you have setup a relevant .dockerignore file to not send anything that is not required up to the Docker engine. If you don't have the file and it is uploading intermediate or output files from your local (non-Docker) build, then any time these files change, you can again trigger stages to run again.</li><li>Make sure that your docker files are ignored in .dockerignore. This is especially true if you have non-standard names for them since they won't be ignored by default whereas "dockerfile" might be.</li><li>In some cases you just need to slow down and think about what is happening and why it is not using cache. Since you can see the first stage that is not using cache, it should be fairly simple to look at what is being copied at that stage and why it might have changed. When we were first using a build server, we were injecting the build version before compiling. When the build ran a second time, git noticed the changed file and reset it back before having a different version injected. Docker correctly saw the change and rebuilt the entire app. We changed it so that version injection only happens before publish and not at the beginning. This made a big difference in rebuild times.<br /></li></ol>