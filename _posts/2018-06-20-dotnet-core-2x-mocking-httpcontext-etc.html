---
layout: post
title: Dotnet core 2.x mocking HttpContext etc.
date: '2018-06-20T03:23:00.002-07:00'
author: Luke Briner
tags:
- MVC
- unit testing
- dotnet
- dotnet core
- HttpResponse
- HttpRequest
- Mocking
- HttpContext
modified_time: '2018-06-20T03:23:48.762-07:00'
---

<h2>Unit Test or Integration Test?</h2>Unit testing and integration testing are two very black-and-white concepts - on paper! A Unit Test for an MVC action should call the code as directly as possible, injecting any mocks into either the controller constructor and/or the action - easy right?<br /><br />Not really! What if you access request, response etc? These should all be injected into the controller right? That would make sense and make it much easier to test writing of headers, reading of request parameters etc.<br /><br />No, you need an integration test right? Integration testing means testing the application with things joined together: databases wired up, services in place and these can be automated too. Except that dotnet core doesn't (obviously) provide a way to inject any mocks. For integration testing, you shouldn't use mocks, which brings me back to the original problem.<br /><br />When testing special actions like uploading files, multi-part forms etc. I need to access the context and in one case, the response since I am writing a file to the response directly. I also need to mock certain other services because I do not want to wire everything up, just to check that the things I think I am setting are actually being set!<br /><h2>How do we mock HttpContext etc. in our dotnet core unit tests?</h2>Things to know first:<br /><br /><ul><li>HttpContext is quite complicated!</li><li>Not all properties have setters, some have to be set indirectly</li><li>ControllerBase does not use the injected IHttpContextAccessor for its Context property</li><li>They use this weird Features mechanism to attach data</li><li>Classes like DefaultHttpResponse have a reference to their parent object (the context), which creates a slight chicken-and-egg problem.</li><li>In my example, I use DI to get my controller instance but you could instead create one directly and pass the service mocks into the constructor yourself.</li></ul><div>So here's what I did, using Moq for mocks and in this case, just providing a concrete response object so that my action could set response headers and query a client ip address without falling over. You could easily extend this for request objects etc:</div><div><br /></div><br /><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">httpContext = new Mock<httpcontext>();</httpcontext></span></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">httpContext.Setup(ct =&gt; ct.Connection.RemoteIpAddress )</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Returns(new System.Net.IPAddress(0x2414188f));</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">contextAccessor = new Mock<ihttpcontextaccessor>();</ihttpcontextaccessor></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">contextAccessor.Setup(ca =&gt; ca.HttpContext)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Returns(httpContext.Object);</span></div></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var features = new FeatureCollection();</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">features.Set<ihttpresponsefeature>(new HttpResponseFeature());</ihttpresponsefeature></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">httpContext.Setup(ct =&gt; ct.Features)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Returns(features);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var response = new DefaultHttpResponse(httpContext.Object);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">httpContext.Setup(ct =&gt; ct.Response)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Returns(response);</span></div></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var controller = ActivatorUtilities.CreateInstance<mobilecontroller>(services);</mobilecontroller></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">controller.ControllerContext = new ControllerContext();</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">controller.ControllerContext.HttpContext = contextAccessor.Object.HttpContext;</span></div></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var result = await controller.GetImage(new GetImageModel { accesstoken = VALID_ACCESS_TOKEN, imagename = VALID_IMAGE_NAME}) as FileStreamResult;</span></div>