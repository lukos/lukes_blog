---
layout: post
title: DotNet Core Dependency Injection does not have named instances
date: '2018-06-13T09:17:00.000-07:00'
author: Luke Briner
tags:
- named
- DI
- Microsoft
- dependency injection
- dotnet
- dotnet core
- core
modified_time: '2018-06-13T09:17:02.358-07:00'
---

I have seen various people asking about named instances on forums for Microsoft Dependency injection and although other DI frameworks support them and they <i>seem</i>&nbsp;useful, it might also be a code smell that can usually be solved by abstracting things a but more!<br /><h2>An Example</h2><div>You might want something like this:</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db1connstring = "whatever";</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db2connstring = "something else";</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">services.AddSingleton<idbconnection>(s =&gt; new DBConn(db1connstring)).Named("db1");</idbconnection></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">services.AddSingleton<idbconnection>(s =&gt; new DBConn(db2connstring)).Named("db2");</idbconnection></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">services.AddSingleton<iservice>(s =&gt; new Service(s.GetNamedService<idbconnection>("db1"), s.GetNamedService<idbconnection>("db2")));</idbconnection></idbconnection></iservice></span></div><div><br /></div><div>It all seems legit, I mean after all, our service requires two db connections of the same type, so we need to disambiguate don't we? We can't do this in Dotnet core either because it isn't supported yet or they took the decision that it can cause more harm than good.</div><h2>Workaround 1 - Concrete types</h2><div>There is a common mistake that types are added to the services collection just for the sake of constructing something else that is explicitly created in registration when we could potentially just pass the types in directly after creating them. Something which is not fully DI but which works for simple cases. In the above example, we <i>could</i>.</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db1connstring = "whatever";</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db2connstring = "something else";</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db1 = new DBConn(db1connstring);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var db2 = new DBConn(db2connstring);</span></div></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">services.AddSingleton<iservice>(new Service(db1, db2));</iservice></span></div><div><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;"><br /></span></div>This works fine as long as nothing else that is being automatically created requires the types IDBConnection since they are no longer registered in the services collection. You could register them as concrete objects in services as well but then they would need to be Singletons since you are only creating a single instance when using a concrete type (you'll notice that only AddSingleton has an overload that takes an object). It would also potentially cause ambiguity again, although it would be fine if they were only used from GetServices() elsewhere.<h2>Workaround 2 - Abstracting the Config</h2><div>If you ever have more than one of the same type in a DI constructor and this is very common with strings, you can instead abstract the whole lot to a configuration type instead of separate items. In our example, we could easily create a ServiceConfiguration type with named properties of the relevant types and inject this configuration instead. In the following example, we have a single Constructor parameter on Service and since the ServiceConfiguration type is available in services, we do not need a lambda for the creation of Service but can use the simple form below.</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var serviceConfiguration = Configuration.Get<serviceconfiguration>();</serviceconfiguration></span></div><div><div><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">serviceConfiguration</span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">.MainDB = new DBConn(</span><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">serviceConfiguration.MainConfig</span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">);</span></div><div><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">serviceConfiguration</span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">.BackupDB = new DBConn(</span><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">serviceConfiguration.BackupConfig</span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">);</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">services.AddSingleton&lt;</span><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">ServiceConfiguration&gt;();</span></div><div><span style="font-family: &quot;Courier New&quot;, Courier, monospace; font-size: x-small;">services.AddSingleton<iservice ervice="">();</iservice></span></div><div><br /></div></div>