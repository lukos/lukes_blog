---
layout: post
title: Calling Web Services from Reporting Services
date: '2009-06-10T03:51:00.000-07:00'
author: Luke Briner
tags:
- Microsoft Reporting Services
- web services
- Reporting Services
- sqlserver 2005
modified_time: '2009-06-10T04:34:39.175-07:00'
---

I wanted to do this because I didn't like the idea that we needed SQL procs in a database for reports that have to do the same thing as business logic dlls did for the web app pages. This duplication not only made things harder (being done twice) but allowed the possibility of breaking one when the other was changed and the fact that SQL is so different from code that one was often much easier to change than the other. I found out that you can call web service functions from reports so that the same code can populate reports AND web pages. It is not massively easy to work it out and my example uses Reporting Services 2005 and .Net 2.0. It also uses the Reporting Services XML Data Provider for the dataset (since the web service returns xml in the form of soap).<br /><ol><br /><li> Create your web service as per a normal web service. In order to be generic and not need changing or growing for every different sort of function I would need to call, I made some generic functions that use reflection to call whatever function I want. You can probably work out what I did if I show you the code for the generic function:<br /><pre><br />[WebMethod()]<br />public ArrayList ExecuteArrayMethod(String typeName, String method, object[] ParamArray)<br />{<br /> ArrayList returnObject = null;<br /> Type type = AccessType(typeName);<br /><br /> try<br /> {<br />  if (type != null && type.GetMethod(method).GetCustomAttributes(typeof(ExportedMethod), false).Length > 0)<br />  {<br />   returnObject = (ArrayList)type.InvokeMember(method, BindingFlags.Default | BindingFlags.InvokeMethod, null, null, ParamArray);<br />  }<br /> }<br /> catch (Exception)<br /> {<br />  throw;<br /> }<br /> return returnObject;<br />}<br /></pre><br />There are a couple of points of note. The ExportedMethod attribute was something I added to control what functions were allowed to be exported to the reports and what couldn't, it is optional. Also, the arraylist allows collections of any type to be exported via the function. I have created a dataset flavour which I haven't tested yet and which I don't think I'll need.</li><br /><li>Obviously the functions that actually generate your report data must be callable from the parameters you have available in your web service. If the function needs a load more information like connection strings, arguments etc, then either pass them in via the web service function or if they are private, create a parent function that can obtain these values and pass them to the worker function. The function you call from the web service must be static (I think!).</li><br /><li>You will need to declare the types of any exported classes (i.e. types put into the ArrayList) at the top above the web service class definition even though you never need to reference them by name in the report. This forces the webservice to include the property data in the xml schema used by callers of the functions. You do this:<br /><pre>[XmlInclude(typeof(ClassName1)), XmlInclude(typeof(ClassName2))]</pre></li><br /></li>You must ensure that these exported classes have default constructors and public getters AND setters for all class properties that you want to access from the report. This allows the system to serialize and de-serialize the objects across the network. The service will build fine but you will get an error when you try and execute the function in reporting services.</li><br /><li>Build and deploy the web service to a url somewhere, such as http://myhost/webservices/myservice.asmx</li><br /><li>Navigate to the asmx file in your browser and click on the function that you will be calling from your report. You should get an invoke section at the top which you can use to ensure that your code is returning the expected data. Do not go straight to the report without checking this, the report syntax is hard enough without the underlying data actually not working! Also note the RESPONSE syntax under the soap 1.2 section (the second of the two brown boxes). It will contain some soap bits (ignore these) and then a response tag, a result tag and then data depending on what you are returning. These are the important bits.</li><br /><li>Open up your reporting services project (or create a new one) and add a datasource of type XML. In the connection string field, put the path to the asmx web service including the http and the asmx filename itself. Under credentials, you will need to put whatever is needed to call functions on this web service. In my case, it is a private intranet so I use windows credentials.</li><br /><li>Create/edit a report and add a new dataset that uses this XML datasource, set the type to text and this is where the fun begins. You need to use a query syntax similar to XPath but not quite (search the web for details, there are various MSDN articles about it). This names the method, the parameters and the expected return values (and optional types). I will show mine so hopefully it makes more sense:<br /><pre><br />&lt;Query><br />  &lt;Method Name="ExecuteArrayMethod" Namespace="Namespace.Of.The.Webservice"><br />      &lt;Parameters><br />       &lt;Parameter Name="typeName"></Parameter><br />       &lt;Parameter Name="method"></Parameter><br />       &lt;Parameter Name="QuoteReference"></Parameter><br />   &lt;/Parameters><br />  &lt;/Method> <br />   &lt;ElementPath IgnoreNamespaces="true"><br />           ExecuteArrayMethodResponse{}/ExecuteArrayMethodResult{}/anyType{Location,Description,Schedule,Item_Code,Quantity(Integer),OriginalSale(Decimal),RevisedSale(Decimal)}<br />&lt;/ElementPath><br />&lt;/Query><br /></pre><br />Note that the anyType is the type that is returned in my soap response because I used an arraylist, it might be something else depending on your data. I have also typed some of the return values so that they can be treated as numbers rather than the string defaults. This XPath relates to the following web service xml response:<br /><pre><br />&lt;soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope"><br />  &lt;soap12:Body><br />    &lt;ExecuteArrayMethodResponse xmlns="Namespace.Of.The.Webservice"><br />      &lt;ExecuteArrayMethodResult><br />        &lt;anyType /><br />        &lt;anyType /><br />      &lt;/ExecuteArrayMethodResult><br />    &lt;/ExecuteArrayMethodResponse><br />  &lt;/soap12:Body><br />&lt;/soap12:Envelope><br /></pre><br /></li><br /><li>Every time you save the xml, it will parse it and give you an error if there is a syntax problem, it does not understand line breaks so you might get a line1, character 300 error or similar, unfortunately, you have to try and build up the element path if your syntax is wrong and hope for the best.</li><br /><li>If your web method requires parameters (as mine does), click on the ellipses next to the dataset (...) and click the parameters tab. You need to define any parameters passed to the method here so either a) use static values (in my case the method parameter is static for any given report) or to use a previously created report parameter if it will be different for each instance of the report (like my QuoteReference is).</li><br /><li>Exit the edit pages and click the ! button to call the method. You might be prompted for parameters and you should see your expected table of data or you might get an error. If you get data but it is incorrect, check your element path. If you get no data, your element path might be wrong or there might be no data being returned, remove the element path and leave it blank to see if there is actually data present, if there is, your element path is still wrong. if you get an error, click the little red X icon and make the dialog bigger, the errors are often hidden but usually useful "no permission", "could not instantitate type" etc</li><br /><li>Once you get data in the right format, your dataset on the left should now show the field names which can be used on the report in the normal way.</li><br /><li>One of the big benefits for us is that the workload is shifted from the database server which also seems to be chugging away to the web server which is fairly lightly loaded since the work is now mostly done in a web service not a view/proc.</li><br /><li>When you deploy your report to another server, you might get other errors and these are sometimes related to the permissions with which the report server is attempting to access your web service with. When you go to the web service in your browser, you are usually logging in as you and you might have access, the report server however logs in to the webservice as the report server (and not the person running the report). I got round this by modifying the datasource on the live server to use specific login credentials rather than windows credentials.</li><br /></ol>