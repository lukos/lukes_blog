---
layout: post
title: Tightening up your Azure Cloud Service SSL Settings
date: '2014-11-04T14:09:00.001-08:00'
author: Luke Briner
tags:
- transport security
- Cipher
- poodle
- Azure
- ssl
- Powershell
- sslv3
- transport layer security
- cloud service
- tls
modified_time: '2014-11-04T14:09:35.034-08:00'
---

<h2>The Background </h2>A lot has happened in the world of SSL in the last 12 months and even though our site started with a nice A grade on the wonderful <a href="https://www.ssllabs.com/" target="_blank">SSL Labs</a> test site, it dipped recently to a paltry C!<br /><br />Firstly, when Heartbleed happened, us Microsofties breathed a sigh of relief that it didn't affect Windows schannel.dll but two others were of concern, the BEAST attack and the more recent POODLE.<br /><br />The BEAST attack was a vulnerability in the CBC mode used by a lot of SSL ciphers and even though RC4 didn't have the vulnerability, there were concerns that other weaknesses in RC4 might mean that it is still better to use CBC. Some fixes were then applied to various components by people like MS and Apple and although TLS 1.1 and 1.2 are not prone to BEAST, they are also less widely adopted by browsers!<br /><br />Anyway, BEAST has kind of died away although POODLE is an attack against SSL v3 and is a reasonably small attack to make (256 requests = 1 byte of information revealed). Although most browsers support TLS 1.0 (the next version above SSLv3), since many/most servers still support SSLv3 from the olden days, not only is the weakness still present for users of older browsers (IE8 on Windows XP for example) but is also allows a downgrade attack, where a man-in-the-middle could negotiate the use of SSLv3 between a newer browser and the server, then allowing it to record and decrypt traffic (potentially). The only way to avoid this is to completely disable SSLv3 and that is what SSL labs is recommending and what Google is planning to ditch in newer versions of Chrome.<br /><br />The bottom line is that people with old browsers will need to upgrade their browser and possibly their OS to continue using these secured sites but also, if there are old servers that still support SSLv3 and older ciphers, it is about time they updated and upgraded.<br /><h2>The Plan</h2>So the plan is simple. Disable all versions of SSL in my Azure Cloud Service, disable older weaker ciphers such as DES, 3DES, RC2, RC4 and disable the by now soon-to-be-dead MD5 hashing algorithm. This leaves me with AES encryption (128 and 256 bit), CBC and GCM counter modes and 3 sizes of the SHA hashing algorithm. According to&nbsp;<a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank">https://wiki.mozilla.org/Security/Server_Side_TLS</a> <span id="goog_1488104414"></span><span id="goog_1488104415"></span>this should be enough to support a medium range of browsers - i.e. not just all the latest and greatest but browsers back to IE8 on Windows 7, for instance. I have since tested the setup on SSL labs and it seems to be happy.<br /><h2>The Solution</h2>How to do it? Well, you can run a <a href="http://msdn.microsoft.com/en-us/library/azure/hh180155.aspx" target="_blank">startup script</a> on your Azure cloud service but the problem is that if you reboot at the end (which you need to do for the settings to take effect), then when the role restarts, it will run the script again and reboot, which means you need some kind of flag to control how it reboots (only do it once). Fortunately, I found a very helpful script on the MS site that basically does this (although not everything I needed to do). For reference, the original is <a href="http://azure.microsoft.com/blog/2014/10/19/how-to-disable-ssl-3-0-in-azure-websites-roles-and-virtual-machines/" target="_blank">here</a>.<br /><br />Their trick is that it checks registry values before setting them and only rebooting if they have changed. This way, when the role reboots and runs the script again, nothing will have changed and the role won't reboot. The problem is that their script only disables SSLv3, it does nothing with removing weak ciphers or hashes but I had the bones of what I needed in their script.<br /><br />I tried simply adding some more registry entries for ciphers that need to be disabled (like "RC4 40/128"), which is when I found out why this was not very easy to do! The existing script uses the generic new-item function to create the registry keys but Powershell, being very helpful, changes the forward slash in the name to a path character, effectively attempting to create RC4 40 and then a sub key of 128 - it fails!<br /><br />What I had to do was rework it to use actual RegistryKey objects so I could call things like "CreateSubKey()" which don't change the slash to a path character.<br /><br />The script is below but some notes are in order!<br /><ol><li>The script is large based on the MS one but with some additions</li><li>I have not used the original suggested cipher suites (although in the original script, this wasn't used anyway) but have used the Mozilla wiki to stick to ECDHE where possible.</li><li>I have included some cipher suites which are not enabled by default (the ones with the curve number on the end like P256). However, I don't know how to enable these so they don't appear in the list of supported ciphers on the SSL labs test, if anyone knows, let me know.</li><li>By all means modify the script if you want to keep some of the ciphers I have removed</li><li>If you save the script as ciphers.ps1 file, make sure its properties say to copy it to the output and you can call it from the startup.cmd file just with <b>PowerShell -ExecutionPolicy Unrestricted .\ciphers.ps1 &gt;&gt; "%TEMP%\StartupLog.txt" 2&gt;&amp;1</b></li></ol><pre># from http://azure.microsoft.com/blog/2014/10/19/how-to-disable-ssl-3-0-in-azure-websites-roles-and-virtual-machines/<br /><br /><br />$nl = [Environment]::NewLine<br />$regkeys = @(<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.0",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.0\Client",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.0\Server",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Client",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Server",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Server",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 2.0",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 2.0\Client",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 2.0\Server",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 3.0",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 3.0\Client",<br />"HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 3.0\Server",<br />"HKLM:\SOFTWARE\Policies\Microsoft\Cryptography\Configuration\SSL\00010002"<br />)<br /># Cipher order as per the original script<br /># $cipherorder = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256,"<br /># $cipherorder += "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256,"<br /># $cipherorder += "TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,"<br /># $cipherorder += "TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,"<br /># $cipherorder += "TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_RC4_128_MD5"<br /><br /># Cipher order as per Mozilla: https://wiki.mozilla.org/Security/Server_Side_TLS (Intermediate set - as mapped to Windows names)<br />$cipherorder = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P521,"<br />$cipherorder += "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P384,"<br />$cipherorder += "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P521,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P521,"<br />$cipherorder += "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521,"<br />$cipherorder += "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P521,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521,"<br />$cipherorder += "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P521,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,"<br />$cipherorder += "TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA"<br /><br /><br /># If any settings are changed, this will change to $True and the server will reboot<br />$reboot = $False<br /><br />Function Set-CryptoSetting {<br />  param (<br />    $keyindex,<br />    $value,<br />    $valuedata,<br />    $valuetype,<br />    $restart<br />  )<br /><br />  # Check for existence of registry key, and create if it does not exist<br />  If (!(Test-Path -Path $regkeys[$keyindex])) {<br /> Write-Host "Creating key: " + $regkeys[$keyindex] + "$nl"<br />    New-Item $regkeys[$keyindex] | Out-Null<br />  }<br /><br />  # Get data of registry value, or null if it does not exist<br />  $val = (Get-ItemProperty -Path $regkeys[$keyindex] -Name $value -ErrorAction SilentlyContinue).$value<br /><br />  If ($val -eq $null) {<br />    # Value does not exist - create and set to desired value<br /> Write-Host "Value " + $regkeys[$keyindex] + "\$value does not exist, creating...$nl"<br />    New-ItemProperty -Path $regkeys[$keyindex] -Name $value -Value $valuedata -PropertyType $valuetype | Out-Null<br />    $restart = $True<br />  } Else {<br />    # Value does exist - if not equal to desired value, change it<br />    If ($val -ne $valuedata) {<br />  Write-Host "Value " + $regkeys[$keyindex] + "\$value not correct, setting it$nl"<br />  Set-ItemProperty -Path $regkeys[$keyindex] -Name $value -Value $valuedata<br />  $restart = $True<br />    }<br /> Else<br /> {<br />  Write-Host "Value " + $regkeys[$keyindex] + "\$value already set correctly$nl"<br /> }<br />  }<br />  return $restart<br />}<br /><br /># Special function that can handle keys that have a forward slash in them. Powershell changes the forward slash<br /># to a backslash in any function that takes a path.<br />Function Set-CryptoKey {<br /> param (<br />  $parent,<br />  $childkey,<br />  $value,<br />  $valuedata,<br />  $valuetype,<br />  $restart<br /> )<br /><br /> $child = $parent.OpenSubKey($childkey, $true);<br /><br /> If ($child -eq $null) {<br />  # Need to create child key<br />  $child = $parent.CreateSubKey($childkey);<br /> }<br /><br /> # Get data of registry value, or null if it does not exist<br />   $val = $child.GetValue($value);<br /><br />   If ($val -eq $null) {<br />  # Value does not exist - create and set to desired value<br />  Write-Host "Value $child\$value does not exist, creating...$nl"<br />  $child.SetValue($value, $valuedata, $valuetype);<br />  $restart = $True<br />   } Else {<br />  # Value does exist - if not equal to desired value, change it<br />  If ($val -ne $valuedata) {<br />   Write-Host "Value $child\$value not correct, setting it$nl"<br />   $child.SetValue($value, $valuedata, $valuetype);<br />   $restart = $True<br />  }<br />  Else<br />  {<br />   Write-Host "Value $child\$value already set correctly$nl"<br />  }<br />   }<br /><br /> return $restart<br />}<br /><br /># Check for existence of parent registry keys (SSL 2.0 and SSL 3.0), and create if they do not exist<br />For ($i = 9; $i -le 12; $i = $i + 3) {<br />  If (!(Test-Path -Path $regkeys[$i])) {<br />    New-Item $regkeys[$i] | Out-Null<br />  }<br />}<br /><br /># Ensure SSL 2.0 disabled for client<br />$reboot = Set-CryptoSetting 10 DisabledByDefault 1 DWord $reboot<br /><br /># Ensure SSL 2.0 disabled for server<br />$reboot = Set-CryptoSetting 11 Enabled 0 DWord $reboot<br /><br /># Ensure SSL 3.0 disabled for client<br />$reboot = Set-CryptoSetting 13 DisabledByDefault 1 DWord $reboot<br /><br /># Ensure SSL 3.0 disabled for server<br />$reboot = Set-CryptoSetting 14 Enabled 0 DWord $reboot<br /><br /># Set cipher priority<br />$reboot = Set-CryptoSetting 15 Functions $cipherorder String $reboot<br /><br /># We have to do something special with these keys if they contain a forward-slash since<br /># Powershell converts the forward slash to a backslash and it screws up the creation of the key!<br />#<br /># Just create these parent level keys first<br />$cipherskey = (get-item HKLM:\).OpenSubKey("SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Ciphers",$true)<br />If ($cipherskey -eq $null) {<br /> $cipherskey = (get-item HKLM:\).CreateSubKey("SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Ciphers")<br />}<br /><br />$hasheskey = (get-item HKLM:\).OpenSubKey("SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Hashes",$true)<br /> If ($hasheskey -eq $null) {<br /> $hasheskey = (get-item HKLM:\).CreateSubKey("SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Hashes")<br />}<br /><br /># Then add sub keys using a different function<br /># Disable RC4, DES, EXPORT, eNULL, aNULL, PSK and aECDH<br />$reboot = Set-CryptoKey $cipherskey "RC4 128/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "Triple DES 168" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC2 128/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC4 64/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC4 56/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC2 56/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "DES 56" Enabled 0 DWord $reboot  # It's not clear whether the key is DES 56 or DES 56/56<br />$reboot = Set-CryptoKey $cipherskey "DES 56/56" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC4 40/128" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $cipherskey "RC2 40/128" Enabled 0 DWord $reboot<br /><br /># Disable MD5, enable SHA (which should be by default)<br />$reboot = Set-CryptoKey $hasheskey "MD5" Enabled 0 DWord $reboot<br />$reboot = Set-CryptoKey $hasheskey "SHA" Enabled 0xFFFFFFFF DWord $reboot<br /><br />$cipherskey.Close();<br />$hasheskey.Close();<br /><br /><br /># If any settings were changed, reboot<br />If ($reboot) {<br />  Write-Host "Rebooting now..."<br />  shutdown.exe /r /t 5 /c "Crypto settings changed" /f /d p:2:4<br />}<br /><br /></pre>