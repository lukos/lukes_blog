---
layout: post
title: "[bug] DiagnosticMonitorTraceListener doesn't use filter"
date: '2014-02-20T04:59:00.000-08:00'
author: Luke Briner
tags:
- Trace Sources
- Azure
- filter
- TraceListener
- diagnostics
modified_time: '2014-02-20T04:59:07.861-08:00'
---

Due to some kind of mistake, the Azure DiagnosticMonitorTraceListener doesn't honour the filter tag in config. In other words, if you add something like &lt;filter initializedata="Warning" type="System.Diagnostics.EventTypeFilter"&gt;, it won't make any difference, all events will be logged.<br /><br />Even though you can specify the level of logs to transfer from local to diagnostics tables in your storage account, I don't really want to log loads of events locally, especially the weird ones from the Azure environment which don't mean anything.<br /><br />I found a forum post with a very painful response from the MS tech team, the type of reply that says, "are you saying...?" to which the original poster says, "no, that is not what I am saying"! The gist was that the only way to do this was to subclass the DiagnosticMonitorTraceListener and add the filtering functionality in.<br /><br />I used reflector to open both the normal TraceListener class and the DiagnosticMonitorTraceListener and found that the DiagnosticMonitorTraceListener had overridden base class functions and somehow missed the filtering code. I also found out, like many MS library classes, that some functions were marked internal and were not accessible to me, I did however get it to work using the following code:<br /><br /><pre>public class DiagnosticMonTraceListener : DiagnosticMonitorTraceListener<br />{<br />    public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data)<br />    {<br />        if (this.Filter != null &amp;&amp; !this.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, data))<br />        {<br />            return;<br />        }<br />        base.TraceData(eventCache, source, eventType, id, data);<br />    }<br /><br />    public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data)<br />    {<br />        if (this.Filter != null &amp;&amp; !this.Filter.ShouldTrace(eventCache, source, eventType, id, null, null, data, null))<br />        {<br />            return;<br />        }<br />        base.TraceData(eventCache, source, eventType, id, data);<br />    }<br /><br />    public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id)<br />    {<br />        this.TraceEvent(eventCache, source, eventType, id, string.Empty);<br />    }<br /><br />    public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)<br />    {<br />        if (this.Filter != null &amp;&amp; !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))<br />        {<br />            return;<br />        }<br />        base.TraceEvent(eventCache, source, eventType, id, message);<br />    }<br /><br />    public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)<br />    {<br />        if (this.Filter != null &amp;&amp; !this.Filter.ShouldTrace(eventCache, source, eventType, id, format, args, null, null))<br />        {<br />            return;<br />        }<br />        base.TraceEvent(eventCache, source, eventType, id, format, args);<br />    }<br />}<br /></pre><br />Which I then used in my web.config in place of the DiagnosticMonitorTraceListener.