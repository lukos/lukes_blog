---
layout: post
title: Calling web services asynchronously in Android
date: '2014-06-17T04:09:00.000-07:00'
author: Luke Briner
tags:
- async
- threading
- Activity
- threads
- web service
- Android
modified_time: '2014-06-17T04:09:09.673-07:00'
---

This is something I had to do when first creating my PixelPin Android App. Depending on what web service client you use, you might find that you cannot call the web service from the main thread without causing an exception. I ended up using the <a href="http://developer.android.com/reference/org/apache/http/client/package-summary.html" target="_blank">Apache web service client</a>, since it matched much more closely with a coding style I was familiar with (the Java one is really confusing!) but it is still not a good idea to call a web service from the main (UI) thread for the simple reason that the call will block, possibly for 10s of seconds in a bad network area and that would cause the UI to lock up which is obviously not good.<br /><br />Below are some code extracts that describe the way in which I call the web service asynchronously using a simple generic class called android.os.AsyncTask, which does most of the heavy lifting to move the blocking code off of the main thread.<br /><h3>The calling Activity</h3><div>So there will obviously be an activity that needs to call the web service, rather than calling this service directly and blocking, we will start the Async task (shown in a minute) and then finish. For instance, our Activity might call something like this:</div><div><br /></div><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>CheckUserCanLoginTask task = new CheckUserCanLoginTask();<br />task.attach(LoginActivity.this);<br />task.execute(email, getDeviceId());<br /></code></pre><br />We will look at the code for the Task in a minute but there are a few things to point out. Firstly, the attach method is what I have used to allow the Task to call back into the Activity when it has finished. You could pass it in as one of the parameters to execute but I think this way is more clear. The execute() function can take a variable number of parameters but they must all be the same type and will be specified in the code for CheckUserCanLoginTask. In my case, String is usually the lowest common denominator so I tend to use String... for the params here. The actual params are not important, in this case they are simply the parameters I need for my task to work. You also don't have to pass any parameters in if they are not relevant.<br /><h3>The Async Task</h3><div>The async class is generic and takes 3 type parameters, the first is the type of the variable length params list passed to the execute() function, the second is the type of the function that can be called to check on the progress of the task (if relevant, I don't tend to use this for the web service calls) and the 3rd type is the type of the result that is passed from the async function doInBackground to the 'finished' function, which is called onPostExecute. My code for this specific task looks like this:</div><div><br /></div><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>package org.PixelPin.PixelPinMobile;<br /><br />import android.os.AsyncTask;<br /><br />public class CheckUserCanLoginTask extends AsyncTask&lt;String,String,String&gt; {<br />    <br />    private LoginActivity activity;<br />    <br />    public void attach(LoginActivity act)<br />    {<br />        activity = act;<br />    }<br />    <br />    @Override<br />    protected String doInBackground(String... params) {<br />        <br />        return PixelPinWebService.CheckUserCanLogin(params[0],params[1]);<br />    }<br />    <br />    @Override<br />    protected void onPostExecute(String result) {<br />        activity.CheckUserFinished(result);<br />    }<br /><br />}<br /><br /></code></pre><br />There isn't much that is complicated here but note that the doInBackground() function is asynchronous, it is NOT the same as the execute function that you call from the Activity, which starts up a thread to run doInBackground(). Obviously, you could do a whole load of stuff in here and even use the progress functionality if you want to (I use it on one activity that does multiple steps and it returns an int between 0 and 100 to the calling activity). In this simple case, the task calls one method on a static web service class, which handles the web service client etc. In my case, the web service returns a string which is returned from doInBackground() and is then passed to onPostExecute(). You could consume this here but in my case, the data is to be used by the calling activity, which I call using the reference I attached earlier. <br /><br />Since onPostExecute() is supposed to be called on the main thread, so you can call directly into the activity and any UI elements of that activity but some people have complained about problems with the wrong thread being used (user error?) in which case, simply pass the calls off via new Handler().post(new Runnable() { public void run() { // Code in here } }); <br /><h3>Progress</h3><div>If you want to report progress, the second parameter to AsyncTask is the type of progress. In one of my activities I use an int to report progress. You do this by calling publishProgress(), which takes a variable list of the type you specify for param 2 in AsyncTask, in my case I pass a step number and a percentage. The step number I use to drive some checkboxes and the precentage to drive a progress bar but you can provide only one value or more depending on what you are doing (but all of the same type).</div><div><br /></div><div>The other change required in your AsyncTask implementation is to implement onProgressUpdate(), which takes the same arguments as publishProgress() and which, you have probably guessed, gets called on the main thread when publishProgress() is called. It is here that you can call back into your activity and cause some kind of progress meter to update.</div><div><br /></div><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>@Override<br />protected void onProgressUpdate(Integer... progress) {<br />        mActivity.updateProgress(progress[0],progress[1]);<br />}</code></pre><h3>Conclusion</h3><div>It is quite easy to get async capability using this AsyncTask and there are other features not mentioned here such as handling the task being cancelled so please look up the docs here:&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank">AsyncTask reference</a></div>