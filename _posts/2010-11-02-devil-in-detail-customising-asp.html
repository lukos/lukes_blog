---
layout: post
title: Devil in the detail - customising the ASP BulletedList
date: '2010-11-02T02:48:00.000-07:00'
author: Luke Briner
tags:
- asp.net
- asp:bulletedList
modified_time: '2010-11-02T03:08:52.723-07:00'
---

When you do standard easy programming, you can cover a lot of ground very quickly. Modern tools and class libraries are very useful and do most things very well. When it comes to more specific programming, the devil is very much in the detail. For example, the other day I wanted to replace some hard-coded HTML generation, which made a tabbed divider, with a more standard ASP control. Since our old tab control was based on a &lt;ul&gt;, I found the closest control was an ASP .Net BulletedList.<br />It was easy at first since by setting various options on the list, I could get it to generate a &lt;ul&gt; with items and using the link button mode, it all looked pretty good. I applied the original CSS styles and I thought I was 99% there.<br />Oh, I thought, I really need to distinguish the selected item in the list since they represent tabs, I want to style the selected one differently. Since the bulleted list is supposed to be, well, a bulleted list, all the item selection from the base class ListControl has been overridden with NotImplementedExceptions and even if an item is selected by getting the individual ListItem and setting Selected = true, the item is not rendered any differently.<br />Well, this wasn't a problem since OO allows us to inherit and extend the functionality, I implemented my own version of RenderContents() in a new class, inherited from BulletedList which renders an attribute for class in the LI if it is selected, this was all great - OO is amazing! I then wanted it to remember the selected item between postbacks and to fire the SelectedIndexChanged ListControl event when the tab had changed. This is where it all started kicking off. For a start, since BulletedList has overridden the ListControl SelectedIndex and SelectedValue setters, I could not call the original versions which were fine, I had to use the Red Gate reflector tool to find the original code and duplicate it in my class overriding the overridings! I then found various references to internal and private functions which, again, I needed to duplicate in my code in order to use the code I had copied from the internal workings of the ListControl (I only wanted to make small changes!). I then realised that since the BulletedList already handle the click event and did not fire the SelectedIndexChanged even from ListControl, I would not easily be able to do what I wanted.<br />In the end, I decided the easiest thing was to inherit directly from ListControl which would give me all the Item selection code and then add in anything from the BulletList class that I needed (fortunately not all of it!) and then I could make my own class handle the postback event when it was clicked and fire the OnSelectedIndexChanged event from ListControl.<br />I removed any of the display modes and bullet types that I was not using to make it neater and got rid of the start bullet number. I also got rid of the various local variables used to "cache" values for loops. It seems that MS did not consider very well how their code would be specialised in sub-classes which is why there is a hotchpotch of public, protected and private/internal functions meaning that trying to base your code on the original does not work without lots of duplication (unless there are other public utlities to do the same things).<br />Anyway, if you're interested in the code:<br /><pre><br />/// <summary><br />/// A specialisation of the list control which is based on link buttons and tab styles<br />/// </summary><br />public class SelectableTabControl : ListControl, IPostBackEventHandler<br />{<br /> protected override void OnInit(EventArgs e)<br /> {<br />  base.OnInit(e);<br />  this.CssClass = "tablist";<br /> }<br /><br /> /// <summary><br /> /// Handle the data being bound<br /> /// </summary><br /> /// <param name="e"></param><br /> /// <remarks>Ensure a default item is selected</remarks><br /> protected override void OnDataBound(EventArgs e)<br /> {<br />  base.OnDataBound(e);<br />  if (SelectedIndex == -1 && Items.Count > 0)<br />  {<br />   SelectedIndex = 0;<br />  }<br /> }<br /><br /> /// <summary><br /> /// Add attributes of this control to the HTML<br /> /// </summary><br /> /// <param name="writer">The HTML output stream</param><br /> protected override void AddAttributesToRender(HtmlTextWriter writer)<br /> {<br />  string uniqueID = this.UniqueID;<br />  if (uniqueID != null)<br />  {<br />   writer.AddAttribute(HtmlTextWriterAttribute.Name, uniqueID);<br />  }<br />  base.AddAttributesToRender(writer);<br /> }<br /><br /> /// <summary><br /> /// Render the HTML for this control<br /> /// </summary><br /> /// <param name="writer">The HTML output stream</param><br /> protected override void Render(HtmlTextWriter writer)<br /> {<br />  if (this.Items.Count != 0)<br />  {<br />   base.Render(writer);<br />  }<br /> }<br /><br /> /// <summary><br /> /// Prevent this control from being given child controls<br /> /// </summary><br /> /// <returns></returns><br /> protected override ControlCollection CreateControlCollection()<br /> {<br />  return new EmptyControlCollection(this);<br /> }<br /><br /> /// <summary><br /> /// Render the individual elements for this list<br /> /// </summary><br /> /// <param name="writer"></param><br /> /// <remarks>The default implementation does not render a class for selected items</remarks><br /> protected override void RenderContents(HtmlTextWriter writer)<br /> {<br />  for (int i = 0; i < this.Items.Count; i++)<br />  {<br />   if (this.Items[i].Attributes != null)<br />   {<br />    this.Items[i].Attributes.AddAttributes(writer);<br />   }<br />   writer.AddAttribute(HtmlTextWriterAttribute.Class, this.Items[i].Selected ? "selecteditem" : String.Empty );<br />   writer.RenderBeginTag(HtmlTextWriterTag.Li);<br />   this.RenderBulletText(this.Items[i], i, writer);<br />   writer.RenderEndTag();<br />  }<br /> }<br /><br /> /// <summary><br /> /// Return the tag to use for the overall control<br /> /// </summary><br /> protected override HtmlTextWriterTag TagKey<br /> {<br />  get { return HtmlTextWriterTag.Ul; }<br /> }<br /><br /><br /> /// <summary><br /> /// Render the individual items from the list<br /> /// </summary><br /> /// <param name="item"></param><br /> /// <param name="index"></param><br /> /// <param name="writer"></param><br /> /// <remarks>Replacement for base class function which references inaccessible values. This only includes the LinkButton style</remarks><br /> protected void RenderBulletText(ListItem item, int index, HtmlTextWriter writer)<br /> {<br />  if (!this.Enabled || !item.Enabled)<br />  {<br />   writer.AddAttribute(HtmlTextWriterAttribute.Disabled, "disabled");<br />  }<br />  else<br />  {<br />   writer.AddAttribute(HtmlTextWriterAttribute.Href, this.GetPostBackEventReference(index.ToString(CultureInfo.InvariantCulture)));<br />  }<br />  if (AccessKey.Length != 0)<br />  {<br />   writer.AddAttribute(HtmlTextWriterAttribute.Accesskey, AccessKey);<br />  }<br />  writer.RenderBeginTag(HtmlTextWriterTag.A);<br />  HttpUtility.HtmlEncode(item.Text, writer);<br />  writer.RenderEndTag();<br /><br /> }<br /><br /> #region Code duplicated from internal .Net classes<br /> /// <summary><br /> /// From System.Web.UI.WebControls.BulletedList<br /> /// </summary><br /> /// <param name="eventArgument"></param><br /> /// <returns></returns><br /> private string GetPostBackEventReference(string eventArgument)<br /> {<br />  if (this.CausesValidation && (this.Page.GetValidators(this.ValidationGroup).Count > 0))<br />  {<br />   return ("javascript:" + GetClientValidatedPostback(this, this.ValidationGroup, eventArgument));<br />  }<br />  return this.Page.ClientScript.GetPostBackClientHyperlink(this, eventArgument, true);<br /> }<br /><br /> /// <summary><br /> /// From System.Web.UI.Util<br /> /// </summary><br /> /// <param name="control"></param><br /> /// <param name="validationGroup"></param><br /> /// <param name="argument"></param><br /> /// <returns></returns><br /> private static string GetClientValidatedPostback(Control control, string validationGroup, string argument)<br /> {<br />  string str = control.Page.ClientScript.GetPostBackEventReference(control, argument, true);<br />  return (GetClientValidateEvent(validationGroup) + str);<br /> }<br /><br /> /// <summary><br /> /// From System.Web.UI.Util<br /> /// </summary><br /> /// <param name="validationGroup"></param><br /> /// <returns></returns><br /> private static string GetClientValidateEvent(string validationGroup)<br /> {<br />  if (validationGroup == null)<br />  {<br />   validationGroup = string.Empty;<br />  }<br />  return ("if (typeof(Page_ClientValidate) == 'function') Page_ClientValidate('" + validationGroup + "'); ");<br /> }<br /><br /> /// <summary><br /> /// From System.Web.UI.Control but minus supports event validation which is far too esoteric (and inaccessible)<br /> /// </summary><br /> /// <param name="uniqueID"></param><br /> /// <param name="eventArgument"></param><br /> internal void ValidateEvent(string uniqueID, string eventArgument)<br /> {<br />  if ((this.Page != null))<br />  {<br />   this.Page.ClientScript.ValidateEvent(uniqueID, eventArgument);<br />  }<br /> }<br /> #endregion<br /><br /> /// <summary><br /> /// Gets whether the All tab is selected (which is always the last one)<br /> /// </summary><br /> public bool AllTabSelected<br /> {<br />  get { return SelectedIndex == Items.Count; }<br /> }<br /><br /> #region IPostBackEventHandler Members<br /> /// <summary><br /> /// Handle a postback event occuring.<br /> /// </summary><br /> /// <param name="eventArgument">The value of the event argument</param><br /> /// <remarks>This event is raised when the page is posted back and if the postback was caused by this control then the eventArgument is the index of the tab that was clicked</remarks><br /> public void RaisePostBackEvent(string eventArgument)<br /> {<br />  ValidateEvent(this.UniqueID, eventArgument);<br />  if (this.CausesValidation)<br />  {<br />   this.Page.Validate(this.ValidationGroup);<br />  }<br />  SetPostDataSelection(Convert.ToInt32(eventArgument));<br />  this.OnSelectedIndexChanged(EventArgs.Empty);<br /> }<br /><br /> #endregion<br />}<br /></pre>