---
layout: post
title: RSA Public Key Encryption, Java to PHP
date: '2013-06-26T03:54:00.001-07:00'
author: Luke Briner
tags:
- Java
- PKI
- encryption
- RSA
- Decryption
- Public Key Encryption
- Asymmetric
- php
modified_time: '2013-06-27T06:13:34.822-07:00'
---

I want to use RSA public key encryption to encrypt something in Java in an Android app using a public key and then to decrypt this in a web service in PHP. As with most of these tasks, there are so many variations, file formats, missing functionality and whatever in each language that these tasks can cause muchos confusion.<br /><br />Anyway, I managed it, thanks partly to <a href="http://codeartisan.blogspot.co.uk/2009/05/public-key-cryptography-in-java.html" target="_blank">this </a>article from 2009. Some basic information, I have a public key in DER format, which is the binary format and not the Base64 encoded format. The code to utilise this in Java/Android, from the blog article is like this:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>private String PublicKeyEncrypt(byte[] data)<br />{<br />    PublicKey pk = null;<br />    try<br />    {<br />        InputStream f = getAssets().open("publickey.der");<br />        DataInputStream dis = new DataInputStream(f);<br />        byte[] keyBytes;<br />        keyBytes = new byte[(int)f.available()];<br />        dis.readFully(keyBytes);<br />        dis.close();<br />    <br />        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);<br />        KeyFactory kf = KeyFactory.getInstance("RSA");<br />        pk = kf.generatePublic(spec);<br />    } <br />    catch (Exception e) {<br />        e.printStackTrace();<br />    } <br />    <br />    final byte[] cipherText = encrypt(data, pk);<br />    return Base64.encodeToString(cipherText,Base64.DEFAULT);<br />}<br />    <br />private static byte[] encrypt(byte[] data, PublicKey key) <br />{<br />    byte[] cipherText = null;<br />    try {<br />      final Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");<br />      cipher.init(Cipher.ENCRYPT_MODE, key);<br />      cipherText = cipher.doFinal(data);<br />    } <br />    catch (Exception e) {<br />      e.printStackTrace();<br />    }<br />    return cipherText;<br />}<br /></code></pre><br />Note that getAssets() is just how I obtain the location of the embedded public key in Android. Also note that I use the RSA/ECB/PKCS1Padding. There are variations but this is the most standard of these. You could combine these two methods into one, I just separated them up to make them more readable.<br /><br />The much simpler decryption using a .pem base64 encoded private key in PHP looks like this:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed #999999; color: black; font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>private function DecryptAndValidateData($data)<br />{<br />    try<br />    {<br />        if (openssl_private_decrypt(base64_decode($data), $decrypted, file_get_contents(Yii::getPathOfAlias( 'webroot' ) . '/privatekey.pem')))<br />        {<br />            // Do something with $decrypted<br />        }<br />        catch(CException $e)<br />        {<br />            $this-&gt;sendResponse(500, 'Internal Server Error');<br />        }<br />    }<br />}<br /></code></pre><br />Note that I base64 encoded/decoded the encrypted data since it is sent across a web channel and I didn't want any of the data to be lost or corrupted along any non-ascii safe connections. The Yii stuff is because I am using the Yii framework so obviously the obtaining of the private key file path might be different for you.<br /><br />Easy as that! I started with the .Net version but reading key files is a bit of a pain in .net for some reason and the BouncyCastle library download site is currently broken!<br /><br /><b>EDIT</b><br />If you would like to use OAEP padding instead of PKCS1 (standard) padding, which apparently is a good idea, you can use <b>RSA/ECB/OAEPWithSHA-1AndMGF1Padding</b> in the Java call to Cipher.getInstance and pass the flag <b>OPENSSL_PKCS1_OAEP_PADDING</b> to openssl_private_decrypt as the third parameter in PHP. 