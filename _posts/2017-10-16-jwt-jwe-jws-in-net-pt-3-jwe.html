---
layout: post
title: JWT, JWE, JWS in .Net - Pt 3 - JWE
date: '2017-10-16T04:32:00.001-07:00'
author: Luke Briner
tags:
- ".net"
- JWT
- encryption
- validation
- c#
- JWE
- JWS
modified_time: '2017-10-16T04:32:29.377-07:00'
---

<a href="https://tools.ietf.org/html/rfc7516" rel="nofollow" target="_blank">JWE</a> is the encrypted version of a JWT. Encryption provides a way to ensure privacy of the data from an attacker and if using a pre-shared key, a very strong way of transmitting private data.<br /><br />The .Net version of the JWT libraries does not also require a signature to be applied, you could assume that the data has integrity if you use an AEAD algorithm for encryption - which you should. However, it appears that you cannot validate the token if it does not have a signature - I'm not sure if there is a way to do that or whether it does not make sense to validate a token with no signature?<br /><br />Fortunately, to produce a JWE in .Net is very similar to producing a <a href="http://lukieb.blogspot.co.uk/2017/10/jwt-jwe-jws-in-net.html" target="_blank">JWS</a>, although you need to generate a cryptographically secure symmetrical key as well as using a certificate to sign it. Naturally, all of this has overhead so although encryption-by-default can be useful, it does come at a price, especially for high-volume systems.<br /><br />To create a key (the Content Encryption Key - CEK) , you can either just use RNGCryptoServiceProvider from the&nbsp;System.Security.Cryptography namespace like this:<br /><br /><pre>var crng = new RNGCryptoServiceProvider();<br />var keyBytes = new byte[32];   // 256 bits for AES256<br />crng.GetBytes(keyBytes);<br /></pre><br />Or you can hash some other piece of data using SHA256 to stretch it. Be careful with this method since you need the input to the SHA function to already be cryptographically secure random or an attacker could discover a pattern and work out how you generate your keys! For instance, do not stretch a numeric userid or guid. In my case, I was stretching a 32 character randomly generated "secret" from an oauth credential to create my pre-shared key.<br /><br /><pre>var keyBytes = SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes("some data to stretch"));<br /></pre><br />Be careful with SHA256 and other cryptography classes for thread safety. It might be quicker to pre-create certain types like SHA256 but if ComputeHash is not thread safe, you might break something when used by multiple threads. I believe some forms of the .Net cryptography classes are thread safe and others are not.<br /><br />Once you have your CEK, the only extra step is to create EncryptingCredentials as well as SigningCredentials:<br /><br /><pre>var symSecurityKey = new SymmetricSecurityKey(keyBytes);<br />var creds = new EncryptingCredentials(symSecurityKey, SecurityAlgorithms.Aes256KW, SecurityAlgorithms.Aes256CbcHmacSha512);<br /></pre><br />Note that you need to use algorithms that are supported in .Net (I can't guarantee that the SecurityAlgorithms enum equates to what is supported), that the selected algorithms match the length of the key provided (i.e. 32 bytes for AES256) and that the <i>second</i> algorithm, which is used to encrypt the actual data is a type that includes authenticated data - i.e. a signature for the encrypted data to verify it was not tampered with before decrypting (such as GCM or HMACSHA). If you choose the wrong length of key, the call to CreateSecurityToken will throw a ArgumentOutOfRangeException. The <i>first</i>&nbsp;algorithm is the one that will be used to encrypt the key itself before it is added to the JWE token.<br /><br />You can use RSA-OAEP for the first parameter but this is <i>not</i> the same as when it is used for the JWE. Firstly, it will only use a 256 bit key for RSA to match the second algorithm (the size of the key) but also, it will need a public key to encrypt and the recipient of the token will need the related private key to decrypt the CEK.<br /><br />By providing the SigningCredentials <i>and</i> EncryptingCredentials to the call to CreateSecurityToken(), the library will create the token, sign it and then encrypt this as the payload in an outer JWE. This means that the header for the JWT will only contain data about the encrypting parameters (alg, enc etc) and only after it is decrypted, will the signing parameters be visible.<br /><br />As mentioned before, you do not have to set a SigningCredential but when I tried this, the call to ValidateToken failed which sounds like it cannot validate data that is only encrypted, which might be possible to bypass (since the encrypted data already requires the use of an authenticated algorithm),<br /><br />Validating is otherwise the same as it is for <a href="http://lukieb.blogspot.co.uk/2017/10/jwt-jwe-jws-in-net-pt-2-validating-jws.html" target="_blank">JWS</a>, except for also setting the value of the TokenDecryptionKey in the&nbsp;TokenValidationParameters in the same way as it was set when it was created.